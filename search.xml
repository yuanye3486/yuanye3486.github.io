<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Java interview Summary]]></title>
      <url>/2018/03/08/java-interview-summary/</url>
      <content type="html"><![CDATA[<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="面向对象的特征：抽象、继承、封装和多态"><a href="#面向对象的特征：抽象、继承、封装和多态" class="headerlink" title="面向对象的特征：抽象、继承、封装和多态"></a>面向对象的特征：抽象、继承、封装和多态</h3><ol>
<li><strong>抽象</strong>：就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。<br>抽象包括两个方面，一是过程抽象，二是数据抽象。</li>
<li><strong>继承</strong>：是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生<br>类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。</li>
<li><strong>封装</strong>：是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。</li>
<li><strong>多态性</strong>：是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。</li>
</ol>
<h3 id="final-finally-finalize-的区别"><a href="#final-finally-finalize-的区别" class="headerlink" title="final, finally, finalize 的区别"></a>final, finally, finalize 的区别</h3><p>  final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。<br>  finally 是异常处理语句结构的一部分，表示总是执行。<br>  finalize 是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。</p>
<h3 id="Exception、Error、运行时异常与一般异常有何异同"><a href="#Exception、Error、运行时异常与一般异常有何异同" class="headerlink" title="Exception、Error、运行时异常与一般异常有何异同"></a>Exception、Error、运行时异常与一般异常有何异同</h3><ul>
<li><strong>Thorwable</strong>：（表示可抛出）是所有异常和错误的超类，两个直接子类为：<ul>
<li><strong>Error</strong>：它是由JVM 产生和抛出的，程序无法处理的错误。这些异常发生时，Java 虚拟机一般会选择线程终止。比如 OutOfMemoryError、ThreadDeath等。</li>
</ul>
<ul>
<li><strong>Exception</strong>：是程序本身可以处理的异常，这种异常分两大类运行时异常和非运行时异常。程序中应当尽可能去处理这些异常。<ul>
<li><strong>RuntimeException</strong>（运行时异常，又称不检查异常）都是 RuntimeException 类及其子类异常，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。<br>常见运行时异常：<ul>
<li>NullPointerException</li>
<li>IndexOutOfBoundsException</li>
<li>ClassCastException</li>
<li>NumberFormatException</li>
<li>ArrayIndexOutOfBoundsException</li>
</ul>
</li>
<li><strong>非运行时异常</strong>（又称检查异常）是 RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如 IOException、SQLException 等以及用户自定义的 Exception 异常，一般情况下不自定义检查异常。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>java 异常体系结构图解<br><img src="http://img.blog.csdn.net/20160331115514210" alt="异常图解"></li>
</ul>
<h3 id="int-和-Integer-有什么区别，Integer的值缓存范围"><a href="#int-和-Integer-有什么区别，Integer的值缓存范围" class="headerlink" title="int 和 Integer 有什么区别，Integer的值缓存范围"></a>int 和 Integer 有什么区别，Integer的值缓存范围</h3><p>  Java 提供两种不同的类型：引用类型和原始类型（或内置类型）。Int 是 java 的原始数据类型，Integer 是 java 为 int 提供的封装类。<br>  Java 为每个原始类型提供了封装类，原始类型封装类具体如下：<br>    boolean Boolean<br>    char    Character<br>    byte    Byte<br>    short   Short<br>    int     Integer<br>    long    Long<br>    float   Float<br>    double  Double<br>  引用类型和原始类型的行为完全不同，并且它们具有不同的语义。<br>  引用类型和原始类型具有不同的特征和用法，它们包括：大小和速度问题，这种类型以哪种类型的数据结构存储，当引用类型和原始类型用作某个类的实例数据时所指定的缺省值。<br>  对象引用实例变量的缺省值为 null，而原始类型实例变量的缺省值与它们的类型有关。</p>
<h3 id="包装类，装箱和拆箱"><a href="#包装类，装箱和拆箱" class="headerlink" title="包装类，装箱和拆箱"></a>包装类，装箱和拆箱</h3><h3 id="String、StringBuilder、StringBuffer"><a href="#String、StringBuilder、StringBuffer" class="headerlink" title="String、StringBuilder、StringBuffer"></a>String、StringBuilder、StringBuffer</h3><h3 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h3><h3 id="抽象类和接口有什么区别"><a href="#抽象类和接口有什么区别" class="headerlink" title="抽象类和接口有什么区别"></a>抽象类和接口有什么区别</h3><ul>
<li>声明方法的存在而不去实现它的类被叫做抽象类（abstract class），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。不能创建 abstract 类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例。不能有抽象构造函数或抽象静态方法。</li>
<li>Abstract 类的子类为它们父类中的所有抽象方法提供实现，否则它们也是抽象类为。取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法。</li>
<li>接口（interface）是抽象类的变体。在接口中，所有方法都是抽象的。多继承性可通过实现这样的接口而获得。接口中的所有方法都是抽象的，没有一个有程序体。接口只可以定义static final成员变量。接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。然后，它可以在实现了该接口的类的任何对象上调用接口的方法。由于有抽象类，它允许使用接口名作为引用变量的类型。通常的动态联编将生效。引用可以转换到接口类型或从接口类型转换，instanceof 运算符可以用来决定某对象的类是否实现了接口。</li>
</ul>
<h3 id="说说反射的用途及实现"><a href="#说说反射的用途及实现" class="headerlink" title="说说反射的用途及实现"></a>说说反射的用途及实现</h3><h3 id="说说自定义注解的场景及实现"><a href="#说说自定义注解的场景及实现" class="headerlink" title="说说自定义注解的场景及实现"></a>说说自定义注解的场景及实现</h3><ul>
<li><img src="https://upload-images.jianshu.io/upload_images/3458176-c5642804973c8b6e.jpg?imageMogr2/auto-orient/" alt="Annotation 思维导图"></li>
</ul>
<ul>
<li><p>Annotation 如何被处理？</p>
<ul>
<li><p>当Java源代码被编译时，编译器的一个插件 annotation 处理器则会处理这些 annotation。处理器可以产生报告信息，或者创建附加的Java源文件或资源。如果annotation本身被加上了RententionPolicy的运行时类，则Java编译器则会将annotation的元数据存储到class文件中。然后，Java虚拟机或其他的程序可以查找这些元数据并做相应的处理。</p>
</li>
<li><p>当然除了annotation处理器可以处理annotation外，我们也可以使用反射自己来处理annotation。Java SE 5有一个名为AnnotatedElement的接口，Java的反射对象类Class,Constructor,Field,Method以及Package都实现了这个接口。这个接口用来表示当前运行在Java虚拟机中的被加上了annotation的程序元素。通过这个接口可以使用反射读取annotation。AnnotatedElement接口可以访问被加上RUNTIME标记的annotation，相应的方法有getAnnotation,getAnnotations,isAnnotationPresent。由于Annotation类型被编译和存储在二进制文件中就像class一样，所以可以像查询普通的Java对象一样查询这些方法返回的Annotation。</p>
</li>
</ul>
</li>
</ul>
<h3 id="HTTP请求的GET与POST方式的区别"><a href="#HTTP请求的GET与POST方式的区别" class="headerlink" title="HTTP请求的GET与POST方式的区别"></a>HTTP请求的GET与POST方式的区别</h3><h3 id="Session-与-Cookie-区别"><a href="#Session-与-Cookie-区别" class="headerlink" title="Session 与 Cookie 区别"></a>Session 与 Cookie 区别</h3><ol>
<li>Cookie 数据存放在客户的浏览器上，而 Session 数据放在服务器上；</li>
<li>Cookie 分发是通过扩展 HTTP 协议来实现的，服务器通过在 HTTP 的响应头中加上一行特殊的指示以提示浏览器按照指示生成相应的 Cookie</li>
<li>Cookie 不是很安全，可以分析存放在本地的 Cookie 并进行 Cookie 欺骗，出于安全考虑应当使用 Session；</li>
<li>Session 会在一定时间内保存在服务器上，当访问增多时会比较影响服务器的性能，出于考虑减轻服务器性能方面，应当使用 Cookie；单个 Cookie 保存的数据不能超过 4K，大多说浏览器都限制了一个站点最多保存 20 个 Cookie。<br>个人观点认为将一些登录信息（重要信息）存放在 Session 中，而其他信息如果需要保留，可以放在 Cookie 中</li>
</ol>
<h3 id="列出自己常用的JDK包"><a href="#列出自己常用的JDK包" class="headerlink" title="列出自己常用的JDK包"></a>列出自己常用的JDK包</h3><ul>
<li>java.lang</li>
<li>java.util</li>
<li>java.io</li>
</ul>
<h3 id="MVC设计思想"><a href="#MVC设计思想" class="headerlink" title="MVC设计思想"></a>MVC设计思想</h3><ul>
<li>M 即Model(模型层)，主要负责业务逻辑以及数据库的交互</li>
<li>V 即View(视图层)，主要用于显示数据和提交数据</li>
<li>C 即Controller(控制器)，主要是用作捕获请求并控制请求转发</li>
</ul>
<h3 id="equals-与-的区别"><a href="#equals-与-的区别" class="headerlink" title="equals 与 == 的区别"></a>equals 与 == 的区别</h3><p>  == 比较两个对象的引用值是否指相同。<br>  equals()：根据 equals() 实现的逻辑比较两个对象是否相同（默认实现是通过 == 比较）。</p>
<h3 id="String-类为什么是-final-的？"><a href="#String-类为什么是-final-的？" class="headerlink" title="String 类为什么是 final 的？"></a>String 类为什么是 final 的？</h3><p>  主要考虑到“安全”和“效率”的缘故，若String允许被继承，那么它的高度使用率可能会降低程序的性能，因此String被定义成了final。</p>
<h3 id="String、StringBuffer与StringBuilder的区别？"><a href="#String、StringBuffer与StringBuilder的区别？" class="headerlink" title="String、StringBuffer与StringBuilder的区别？"></a>String、StringBuffer与StringBuilder的区别？</h3><p>  java 提供了两个类：String和StringBuffer，java1.5 新增 java.lang.StringBuilder 一个可变的字符序列。<br>  简单地说，就是一个变量和常量的关系。StringBuffer 对象的内容可以修改；而 String 对象一旦产生后就不可以被修改，重新赋值其实是两个对象。</p>
<p>  StringBuffer<br>  StringBuffer的内部实现方式和String不同，StringBuffer在进行字符串处理时，不生成新的对象，在内存使用上要优于String类。所以在实际使用时，如果经常需要对一个字符串进行修改，例如插入、删除等操作，使用StringBuffer要更加适合一些。</p>
<p>  String<br>  在String类中没有用来改变已有字符串中的某个字符的方法，由于不能改变一个java字符串中的某个单独字符，所以在JDK文档中称String类的对象是不可改变的。然而，不可改变的字符串具有一个很大的优点:编译器可以把字符串设为共享的。</p>
<p>  StringBuilder<br>  StringBuilder 一个可变的字符序列是5.0新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。两者的方法基本相同。</p>
<h3 id="什么是序列化以及用途，什么时候使用序列化？"><a href="#什么是序列化以及用途，什么时候使用序列化？" class="headerlink" title="什么是序列化以及用途，什么时候使用序列化？"></a>什么是序列化以及用途，什么时候使用序列化？</h3><p>  序列化是指把对象转换为字节序列的过程称为对象的序列化；而反序列化是指把字节序列恢复为对象的过程称为对象的反序列化。</p>
<ul>
<li>对象的序列化主要有两种用途：<ul>
<li>把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中。</li>
<li>在网络上传送对象的字节序列。</li>
</ul>
</li>
<li>什么时候使用序列化：<ul>
<li>1）对象序列化可以实现分布式对象。主要应用例如：RMI要利用对象序列化运行远程主机上的服务，就像在本地机上运行对象时一样。</li>
<li>2）java对象序列化不仅保留一个对象的数据，而且递归保存对象引用的每个对象的数据。可以将整个对象层次写入字节流中，可以保存在文件中或在网络连接上传递。利用对象序列化可以进行对象的”深复制”，即复制对象本身及引用的对象本身。序列化一个对象可能得到整个对象序列。</li>
</ul>
</li>
</ul>
<h3 id="hashCode-和-equals-方法的区别与联系"><a href="#hashCode-和-equals-方法的区别与联系" class="headerlink" title="hashCode 和 equals 方法的区别与联系"></a>hashCode 和 equals 方法的区别与联系</h3><h3 id="什么是Java序列化和反序列化，如何实现Java序列化？或者请解释Serializable-接口的作用"><a href="#什么是Java序列化和反序列化，如何实现Java序列化？或者请解释Serializable-接口的作用" class="headerlink" title="什么是Java序列化和反序列化，如何实现Java序列化？或者请解释Serializable 接口的作用"></a>什么是Java序列化和反序列化，如何实现Java序列化？或者请解释Serializable 接口的作用</h3><h3 id="Object类中常见的方法，为什么-wait-notify-会放在-Object-里边？"><a href="#Object类中常见的方法，为什么-wait-notify-会放在-Object-里边？" class="headerlink" title="Object类中常见的方法，为什么 wait  notify 会放在 Object 里边？"></a>Object类中常见的方法，为什么 wait  notify 会放在 Object 里边？</h3><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><h3 id="Java-8-有哪些新特性"><a href="#Java-8-有哪些新特性" class="headerlink" title="Java 8 有哪些新特性"></a>Java 8 有哪些新特性</h3><h2 id="Java常见集合"><a href="#Java常见集合" class="headerlink" title="Java常见集合"></a>Java常见集合</h2><h3 id="List、Set、Map-的区别"><a href="#List、Set、Map-的区别" class="headerlink" title="List、Set、Map 的区别"></a><a href="https://blog.csdn.net/qq_22118507/article/details/51576319" target="_blank" rel="noopener">List、Set、Map 的区别</a></h3><ol>
<li>List,Set都是继承自Collection接口，Map则不是</li>
<li>List特点：元素有放入顺序可重复。<br>Set特点：元素无放入顺序不可重复，重复元素会覆盖掉，（注意：元素虽然无放入顺序，但是元素在set中的位置是有该元素的HashCode决定的，其位置其实是固定的，加入Set 的Object必须定义 equals()方法 ，另外list支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。）</li>
<li>List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变。<br>Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。</li>
<li>Map适合储存键值对的数据</li>
<li>LinkedList、ArrayList、HashSet 是非线程安全的，Vector是线程安全的;<br>HashMap 是非线程安全的，HashTable 是线程安全的;<br>StringBuilder是非线程安全的，StringBuffer是线程安全的。</li>
</ol>
<h3 id="HashSet-如何保证不重复"><a href="#HashSet-如何保证不重复" class="headerlink" title="HashSet 如何保证不重复"></a>HashSet 如何保证不重复</h3><p>  HashSet中的元素存储在 HashMap中，当向HashSet add()元素的时，会判断元素是否存在的依据，不仅仅是hash码值就能够确定的，同时还要结合equles方法。</p>
<h3 id="HashMap-是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）"><a href="#HashMap-是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）" class="headerlink" title="HashMap 是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）?"></a><a href="https://www.jianshu.com/p/e2f75c8cce01" target="_blank" rel="noopener">HashMap 是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）?</a></h3><ol>
<li>put 的时候导致的多线程数据不一致。</li>
<li>HashMap 的get操作可能因为resize而引起死循环（cpu 100%）<br>参考：</li>
</ol>
<ul>
<li><a href="https://coolshell.cn/articles/9606.html" target="_blank" rel="noopener">JAVA HashMap 的死循环</a></li>
</ul>
<h3 id="HashMap-的扩容过程"><a href="#HashMap-的扩容过程" class="headerlink" title="HashMap 的扩容过程"></a>HashMap 的扩容过程</h3><ol>
<li><a href="http://www.importnew.com/23907.html" target="_blank" rel="noopener">深入分析ConcurrentHashMap1.8的扩容实现</a></li>
</ol>
<h3 id="HashMap-1-7-与-1-8-的-区别，1-8-做了哪些优化，如何优化的？"><a href="#HashMap-1-7-与-1-8-的-区别，1-8-做了哪些优化，如何优化的？" class="headerlink" title="HashMap 1.7 与 1.8 的 区别，1.8 做了哪些优化，如何优化的？"></a>HashMap 1.7 与 1.8 的 区别，1.8 做了哪些优化，如何优化的？</h3><h3 id="LinkedHashMap-的应用"><a href="#LinkedHashMap-的应用" class="headerlink" title="LinkedHashMap 的应用"></a>LinkedHashMap 的应用</h3><h3 id="Set-和-hashCode-以及-equals-方法的联系"><a href="#Set-和-hashCode-以及-equals-方法的联系" class="headerlink" title="Set 和 hashCode 以及 equals 方法的联系"></a>Set 和 hashCode 以及 equals 方法的联系</h3><h3 id="Arraylist-与-LinkedList-区别"><a href="#Arraylist-与-LinkedList-区别" class="headerlink" title="Arraylist 与 LinkedList 区别"></a>Arraylist 与 LinkedList 区别</h3><h3 id="ArrayList-与-Vector-区别"><a href="#ArrayList-与-Vector-区别" class="headerlink" title="ArrayList 与 Vector 区别"></a>ArrayList 与 Vector 区别</h3><h3 id="HashMap、Hashtable-和-HashSet-的区别"><a href="#HashMap、Hashtable-和-HashSet-的区别" class="headerlink" title="HashMap、Hashtable 和 HashSet 的区别"></a><a href="http://www.cnblogs.com/lzrabbit/p/3721067.html#h1" target="_blank" rel="noopener">HashMap、Hashtable 和 HashSet 的区别</a></h3><h3 id="HashMap-和-ConcurrentHashMap-的区别"><a href="#HashMap-和-ConcurrentHashMap-的区别" class="headerlink" title="HashMap 和 ConcurrentHashMap 的区别"></a>HashMap 和 ConcurrentHashMap 的区别</h3><p>  可参考：<a href="http://www.importnew.com/28263.html" target="_blank" rel="noopener">Java7/8 中的 HashMap 和 ConcurrentHashMap 全解析</a></p>
<h3 id="HashMap-的工作原理及代码实现，什么时候用到红黑树"><a href="#HashMap-的工作原理及代码实现，什么时候用到红黑树" class="headerlink" title="HashMap 的工作原理及代码实现，什么时候用到红黑树"></a>HashMap 的工作原理及代码实现，什么时候用到红黑树</h3><h3 id="多线程情况下-HashMap-死循环的问题"><a href="#多线程情况下-HashMap-死循环的问题" class="headerlink" title="多线程情况下 HashMap 死循环的问题"></a>多线程情况下 HashMap 死循环的问题</h3><h3 id="HashMap-出现-Hash-DOS-攻击的问题"><a href="#HashMap-出现-Hash-DOS-攻击的问题" class="headerlink" title="HashMap 出现 Hash DOS 攻击的问题"></a>HashMap 出现 Hash DOS 攻击的问题</h3><h3 id="ConcurrentHashMap-的工作原理及代码实现，如何统计所有的元素个数"><a href="#ConcurrentHashMap-的工作原理及代码实现，如何统计所有的元素个数" class="headerlink" title="ConcurrentHashMap 的工作原理及代码实现，如何统计所有的元素个数"></a>ConcurrentHashMap 的工作原理及代码实现，如何统计所有的元素个数</h3><h3 id="手写简单的-HashMap"><a href="#手写简单的-HashMap" class="headerlink" title="手写简单的 HashMap"></a>手写简单的 HashMap</h3><h3 id="数组在内存中如何分配"><a href="#数组在内存中如何分配" class="headerlink" title="数组在内存中如何分配"></a>数组在内存中如何分配</h3><h3 id="看过那些-Java-集合类的源码"><a href="#看过那些-Java-集合类的源码" class="headerlink" title="看过那些 Java 集合类的源码"></a>看过那些 Java 集合类的源码</h3><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><h3 id="线程和进程的概念"><a href="#线程和进程的概念" class="headerlink" title="线程和进程的概念"></a>线程和进程的概念</h3><ul>
<li>进程：具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。</li>
<li>线程：它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.</li>
</ul>
<h3 id="线程的生命周期，状态是如何转移的？"><a href="#线程的生命周期，状态是如何转移的？" class="headerlink" title="线程的生命周期，状态是如何转移的？"></a>线程的生命周期，状态是如何转移的？</h3><ul>
<li>线程状态<ol>
<li>新建(NEW)：新创建了一个线程对象。</li>
<li>可运行(RUNNABLE)：线程对象创建后，其他线程(比如 main 线程）调用了该对象的 start() 方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu 的使用权。</li>
<li>运行(RUNNING)：可运行状态(runnable)的线程获得了cpu 时间片（timeslice） ，执行程序代码。</li>
<li>阻塞(BLOCKED)：阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。<ul>
<li>阻塞的情况分三种：<ol>
<li>等待阻塞：运行(running)的线程执行 o.wait() 方法，JVM 会把该线程放入等待队列(waitting queue)中。</li>
<li>同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则 JVM 会把该线程放入锁池(lock pool)中。</li>
<li>其他阻塞：运行(running)的线程执行 Thread.sleep(long ms) 或 t.join() 方法，或者发出了 I/O 请求时，JVM 会把该线程置为阻塞状态。当 sleep() 状态超时、join() 等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。</li>
</ol>
</li>
</ul>
</li>
<li>死亡(DEAD)：线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。</li>
</ol>
</li>
<li>状态转换<br><img src="http://dl.iteye.com/upload/picture/pic/116719/7e76cc17-0ad5-3ff3-954e-1f83463519d1.jpg" alt="状态转换图"></li>
<li>几个方法比较<ol>
<li>Thread.sleep(long millis)：一定是当前线程调用此方法，当前线程进入阻塞，但不释放对象锁，millis 后线程自动苏醒进入可运行状态。作用：给其它线程执行机会的最佳方式。</li>
<li>Thread.yield()：一定是当前线程调用此方法，当前线程放弃获取的 cpu 时间片，由运行状态变会可运行状态，让 OS 再次选择线程。作用：让相同优先级的线程轮流执行，但并不保证一定会轮流执行。实际中无法保证 yield() 达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。Thread.yield() 不会导致阻塞。</li>
<li>t.join()/t.join(long millis)：当前线程里调用其它线程1的 join 方法，当前线程阻塞，但不释放对象锁，直到线程1执行完毕或者 millis 时间到，当前线程进入可运行状态。</li>
<li>obj.wait()：当前线程调用对象的 wait() 方法，当前线程释放对象锁，进入等待队列。依靠 notify()/notifyAll() 唤醒或者 wait(long timeout) timeout 时间到自动唤醒。</li>
<li>obj.notify()：唤醒在此对象监视器上等待的单个线程，选择是任意性的。notifyAll() 唤醒在此对象监视器上等待的所有线程。  </li>
</ol>
</li>
</ul>
<h3 id="并行和并发的概念"><a href="#并行和并发的概念" class="headerlink" title="并行和并发的概念"></a>并行和并发的概念</h3><ul>
<li>并行是指两个或者多个事件在同一时刻发生</li>
<li>并发是指两个或多个事件在同一时间间隔发生</li>
</ul>
<h3 id="创建线程的方式及实现"><a href="#创建线程的方式及实现" class="headerlink" title="创建线程的方式及实现"></a>创建线程的方式及实现</h3><ul>
<li>继承 Thread 类</li>
<li>实现 Runnable 接口</li>
<li>使用 Callable 和 Future</li>
</ul>
<h3 id="同步和异步有何异同，在什么情况下分别使用他们？举例说明。"><a href="#同步和异步有何异同，在什么情况下分别使用他们？举例说明。" class="headerlink" title="同步和异步有何异同，在什么情况下分别使用他们？举例说明。"></a>同步和异步有何异同，在什么情况下分别使用他们？举例说明。</h3><p>  如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。<br>  当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。</p>
<h3 id="进程间通信的方式？可參考JAVA线程间通信的几种方式"><a href="#进程间通信的方式？可參考JAVA线程间通信的几种方式" class="headerlink" title="进程间通信的方式？可參考JAVA线程间通信的几种方式"></a>进程间通信的方式？可參考<a href="http://blog.csdn.net/u011514810/article/details/77131296" target="_blank" rel="noopener">JAVA线程间通信的几种方式</a></h3><ul>
<li>通过在线程之间共享对象就可以了，然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的</li>
</ul>
<h3 id="线程间通信的方式。可参考线程间通信剖析"><a href="#线程间通信的方式。可参考线程间通信剖析" class="headerlink" title="线程间通信的方式。可参考线程间通信剖析"></a>线程间通信的方式。可参考<a href="http://www.jasongj.com/java/thread_communication/" target="_blank" rel="noopener">线程间通信剖析</a></h3><h3 id="为什么需要多线程-多线程的优势"><a href="#为什么需要多线程-多线程的优势" class="headerlink" title="为什么需要多线程(多线程的优势)"></a>为什么需要多线程(多线程的优势)</h3><ol>
<li>更多的计算核心（充分利用硬件资源）</li>
<li>更快的响应时间</li>
<li>更好的编程模型</li>
</ol>
<h3 id="什么是线程安全？"><a href="#什么是线程安全？" class="headerlink" title="什么是线程安全？"></a>什么是线程安全？</h3><ul>
<li>如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。</li>
<li>线程安全也是有几个级别的<ol>
<li>不可变<br>String、Integer、Long 这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用</li>
<li>绝对线程安全<br>不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet</li>
<li>相对线程安全<br>相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个 Vector、有个线程同时在 add 这个 Vector，99% 的情况下都会出现 ConcurrentModificationException，也就是 fail-fast 机制。</li>
<li>线程非安全<br>如：ArrayList、LinkedList、HashMap等都是线程非安全的类    </li>
</ol>
</li>
</ul>
<h3 id="如何保证线程安全？"><a href="#如何保证线程安全？" class="headerlink" title="如何保证线程安全？"></a>如何保证线程安全？</h3><ul>
<li>什么是线程安全？</li>
<li>为什么会出现线程不安全？<br>因为存在有限的共享资源（可变的共享变量），以及多线程的并发访问。</li>
</ul>
<ul>
<li>如何解决？<ul>
<li>尽量避免使用可变的共享变量</li>
<li>使用不可变的共享变量<br>可以使用final修饰的对象保证线程安全，由于final修饰的引用型变量(除String外)不可变是指引用不可变，但其指向的对象是可变的，所以此类必须安全发布，也即不能对外提供可以修改final对象的接口。</li>
</ul>
<ul>
<li>线程同步<ul>
<li>加锁<ol>
<li>锁能使其保护的代码以串行的形式来访问，当给一个复合操作加锁后，能使其成为原子操作。一种错误的思想是只要对写数据的方法加锁，其实这是错的，对数据进行操作的所有方法都需加锁，不管是读还是写。</li>
<li>加锁时需要考虑性能问题，不能总是一味地给整个方法加锁synchronized就了事了，应该将方法中不影响共享状态且执行时间比较长的代码分离出去。</li>
<li>加锁的含义不仅仅局限于互斥，还包括可见性。为了确保所有线程都能看见最新值，读操作和写操作必须使用同样的锁对象。</li>
</ol>
</li>
<li>CAS 算法</li>
</ul>
</li>
<li>volatile<ul>
<li>volatile：写内存语义是直接刷新到主内存中，读的内存语义是直接从主内存中读取。</li>
<li>volatile 内存语义实现原理<br>  对于一般的变量则会被重排序，而对于volatile则不能，这样会影响其内存语义，所以为了实现volatile的内存语义JMM会限制重排序。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="什么是-CAS，CAS-有什么缺陷，如何解决？"><a href="#什么是-CAS，CAS-有什么缺陷，如何解决？" class="headerlink" title="什么是 CAS，CAS 有什么缺陷，如何解决？"></a>什么是 CAS，CAS 有什么缺陷，如何解决？</h3><p>  比较并交换(compare and swap, CAS)，是原子操作的一种，可用于在多线程编程中实现不被打断的数据交换操作，从而避免多线程同时改写某一数据时由于执行顺序不确定性以及中断的不可预知性产生的数据不一致问题。CAS操作基于CPU提供的原子操作指令实现，各个编译器根据这个特点实现了各自的原子操作函数。<br>  简单说：CAS需要检查操作值有没有发生改变，如果没有发生改变则更新。</p>
<ul>
<li>优点：无锁；非阻塞</li>
<li>缺点：<ol>
<li>循环时间太长<br>如果CAS一直不成功呢？这种情况绝对有可能发生，如果自旋CAS长时间地不成功，则会给CPU带来非常大的开销。在JUC中有些地方就限制了CAS自旋的次数，例如BlockingQueue的SynchronousQueue。</li>
<li>只能保证一个共享变量的原子操作（当然如果你有办法把多个变量整成一个变量，利用CAS也不错。例如读写锁中state的高地位）</li>
<li>存在 ABA问题<ul>
<li>概念：如果一个值原来是A，变成了B，然后又变成了A，那么在CAS检查的时候会发现没有改变，但是实质上它已经发生了改变，这就是所谓的ABA问题。</li>
<li>解决：AtomicStampedReference 它可以通过控制变量值的版本来保证CAS的正确性，从而避免ABA问题。</li>
<li>引申：Java concurrent 并发包依赖于 CAS 算法，既然 CAS算法存在 ABA 问题，那是不是 AtomicInteger 等根本就不能用了呢？<br>肯定是可以用的，AtomicInteger处理的一个数值，所有就算出现ABA问题问题，也不会有什么影响；但是如果这里是一个地址（地址被重用是很经常发生的，一个内存分配后释放了，再分配，很有可能还是原来的地址），比较地址发现没有问题，但其实这个对象早就变了，这时候就可以使用AtomicStampedReference来解决ABA问题。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="说说-CountDownLatch-CyclicBarrier-Semaphore-原理和区别"><a href="#说说-CountDownLatch-CyclicBarrier-Semaphore-原理和区别" class="headerlink" title="说说 CountDownLatch, CyclicBarrier, Semaphore 原理和区别"></a>说说 CountDownLatch, CyclicBarrier, Semaphore 原理和区别</h3><ul>
<li>概念<ul>
<li>CountDownLatch：是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程的操作执行完后再执行。</li>
<li>CyclicBarrier： 它可以实现让一组线程等待至某个状态之后再全部同时执行。</li>
<li>Semaphore（默认非公平）：是一种基于计数的信号量。它可以设定一个阈值，基于此，多个线程竞争获取许可信号，做完自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。</li>
</ul>
</li>
<li>原理<ul>
<li>CountDownLatch 是通过一个计数器来实现的，计数器的初始值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就会减1。当计数器值到达0时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。</li>
<li>CyclicBarrier 内部定义了一个Lock对象，每当一个线程调用CyclicBarrier的await方法时，将剩余拦截的线程数减1，然后判断剩余拦截数是否为0，如果不是，进入Lock对象的条件队列等待。如果是，执行barrierAction对象的Runnable方法，然后将锁的条件队列中的所有线程放入锁等待队列中，这些线程会依次的获取锁、释放锁，接着先从await方法返回，再从CyclicBarrier的await方法中返回。</li>
</ul>
</li>
<li>应用场景<ul>
<li>CountDownLatch<ol>
<li>实现最大的并行性<br>有时我们想同时启动多个线程，实现最大程度的并行性。例如，我们想测试一个单例类。如果我们创建一个初始计数为1的CountDownLatch，并让所有线程都在这个锁上等待，那么我们可以很轻松地完成测试。我们只需调用 一次countDown()方法就可以让所有的等待线程同时恢复执行。</li>
<li>开始执行前等待n个线程完成各自任务：例如应用程序启动类要确保在处理用户请求前，所有N个外部系统已经启动和运行了。</li>
</ol>
</li>
<li>CyclicBarrier<br>可以用于多线程计算数据,最后合并计算结果的场景  </li>
<li>Semaphore<ol>
<li>可以用来构建一些对象池，资源池之类的，比如数据库连接池。</li>
<li>也可以创建计数为 1 的 Semaphore，将其作为一种类似互斥锁的机制</li>
</ol>
</li>
</ul>
</li>
<li>区别<ul>
<li>CountDownLatch 一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行。</li>
<li>CyclicBarrier 一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行</li>
<li>Semaphore 其实和锁有点类似，它一般用于控制对某组资源的访问权限</li>
<li>实际上可以通过 CountDownLatch 的 countDown() 和 await() 来实现 CyclicBarrier 的功能。即 CountDownLatch 中的 countDown() + await() = CyclicBarrier 中的 await()。注意：在一个线程中先调用countDown()，然后调用await()。</li>
</ul>
</li>
</ul>
<h3 id="说说-Exchanger-原理"><a href="#说说-Exchanger-原理" class="headerlink" title="说说 Exchanger 原理"></a>说说 Exchanger 原理</h3><ul>
<li>Exchanger（交换者）是一个用于线程间协作的工具类。Exchanger 用于进行线程间的数据交换。它提供一个同步点，在这个同步点两个线程可以交换彼此的数据。这两个线程通过 exchange 方法交换数据，如果第一个线程先执行 exchange 方法，它会一直等待第二个线程也执行 exchange，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。</li>
<li>使用场景：Exchanger 也可以用于校对工作</li>
</ul>
<h3 id="ThreadLocal-原理分析，ThreadLocal-为什么会出现-OOM，出现的深层次原理？"><a href="#ThreadLocal-原理分析，ThreadLocal-为什么会出现-OOM，出现的深层次原理？" class="headerlink" title="ThreadLocal 原理分析，ThreadLocal 为什么会出现 OOM，出现的深层次原理？"></a>ThreadLocal 原理分析，ThreadLocal 为什么会出现 OOM，出现的深层次原理？</h3><ul>
<li>原理：每个Thread 维护一个 ThreadLocalMap 映射表，这个映射表的 key 是 ThreadLocal实例本身，value 是真正需要存储的 Object。<ol>
<li>ThreadLocal 本身并不存储值，它只是作为一个 key 来让线程从 ThreadLocalMap 获取 value。</li>
<li>ThreadLocalMap 是使用 ThreadLocal 的弱引用作为 Key 的，弱引用的对象在 GC 时会被回收。</li>
</ol>
</li>
</ul>
<ul>
<li>作用：提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。<br>ThreadLocal的使用不是为了能让多个线程共同使用某一对象，而是我有一个线程A，其中我需要用到某个对象o，这个对象o在这个线程A之内会被多处调用，而我不希望将这个对象o当作参数在多个方法之间传递，于是，我将这个对象o放到TheadLocal中，这样，在这个线程A之内的任何地方，只要线程A之中的方法不修改这个对象o，我都能取到同样的这个变量o。</li>
<li>与普通变量的区别：每个使用该变量的线程都会初始化一个完全独立的实例副本。ThreadLocal 变量通常被 private static 修饰。当一个线程结束时，它所使用的所有 ThreadLocal 相对的实例副本都可被回收。</li>
</ul>
<ul>
<li>为什么会内存泄漏？<ol>
<li>ThreadLocalMap 使用 ThreadLocal 的弱引用作为 key，如果一个 ThreadLocal 没有外部强引用来引用它，那么系统 GC 时，这个 ThreadLocal 会被回收，ThreadLocalMap 中就会出现 key 为 null 的 Entry，就没有办法访问这些 key 为 null 的 Entry 的 value。如果当前线程再迟迟不结束的话，这些 key 为 null 的 Entry 的 value 就会一直存在一条强引用链：Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value 永远无法回收，造成内存泄漏。</li>
<li>ThreadLocalMap 的设计已经考虑到上述情况，也加了一些防护措施：在ThreadLocal 的 get()，set()，remove() 时都会清除线程 ThreadLocalMap 里所有 key 为 null 的 value。</li>
<li>但上述预防措施并不能保证不会内存泄漏：<ul>
<li>使用 static 的 ThreadLocal，延长了 ThreadLocal 的生命周期，可能导致的内存泄漏。</li>
<li>分配使用了 ThreadLocal 又不再调用 get()，set()，remove() 方法，那么就会导致内存泄漏。</li>
</ul>
</li>
</ol>
</li>
<li>如何避免内存泄漏？<br>每次使用完 ThreadLocal，都调用它的 remove() 方法，清除数据。</li>
</ul>
<ul>
<li><p>适用场景：</p>
<ol>
<li>ThreadLocal 适用于变量在线程间隔离且在方法间共享的场景</li>
</ol>
</li>
<li><p>可参考：</p>
<ol>
<li><a href="http://www.jasongj.com/java/threadlocal/" target="_blank" rel="noopener">正确理解 ThreadLocal 的原理与适用场景</a></li>
<li><a href="http://www.importnew.com/22039.html" target="_blank" rel="noopener">深入分析 ThreadLocal 内存泄漏问题</a></li>
</ol>
</li>
</ul>
<h3 id="讲讲线程池的实现原理"><a href="#讲讲线程池的实现原理" class="headerlink" title="讲讲线程池的实现原理"></a>讲讲线程池的实现原理</h3><h3 id="线程池的几种实现方式"><a href="#线程池的几种实现方式" class="headerlink" title="线程池的几种实现方式"></a>线程池的几种实现方式</h3><ul>
<li><p>ThreadPoolExecutor 构造函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">// 这几个参数都是必须要有的</span></span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>corePoolSize</li>
<li>maximumPoolSize：​最大线程数，线程池允许创建的最大线程数。</li>
<li>workQueue：任务队列，BlockingQueue 接口的某个实现（常使用 ArrayBlockingQueue 和 LinkedBlockingQueue）。</li>
<li>keepAliveTime：空闲线程的保活时间，如果某线程的空闲时间超过这个值都没有任务给它做，那么可以被关闭了。注意这个值并不会对所有线程起作用，如果线程池中的线程数少于等于核心线程数 corePoolSize，那么这些线程不会因为空闲太长时间而被关闭，当然，也可以通过调用 allowCoreThreadTimeOut(true)使核心线程数内的线程也可以被回收。</li>
<li>threadFactory：用于生成线程，一般我们可以用默认的就可以了。通常，我们可以通过它将我们的线程的名字设置得比较可读一些，如 Message-Thread-1， Message-Thread-2 类似这样。</li>
<li>handler：当线程池已经满了，但是又有新的任务提交的时候，该采取什么策略由这个来指定。有几种方式可供选择，像抛出异常、直接拒绝然后返回等，也可以自己实现相应的接口实现自己的逻辑。</li>
</ul>
</li>
<li>线程池中的线程创建时机<ol>
<li>如果当前线程数少于 corePoolSize，那么提交任务的时候创建一个新的线程，并由这个线程执行这个任务；</li>
<li>如果当前线程数已经达到 corePoolSize，那么将提交的任务添加到队列中，等待线程池中的线程去队列中取任务；</li>
<li>如果队列已满，那么创建新的线程来执行任务，需要保证池中的线程数不会超过 maximumPoolSize，如果此时线程数超过了 maximumPoolSize，那么执行拒绝策略。</li>
<li>如果将队列设置为无界队列，那么线程数达到 corePoolSize 后，其实线程数就不会再增长了。</li>
</ol>
</li>
</ul>
<h3 id="如何理解并发的三个特性（问题）：原子性、内存可见性、重排序？"><a href="#如何理解并发的三个特性（问题）：原子性、内存可见性、重排序？" class="headerlink" title="如何理解并发的三个特性（问题）：原子性、内存可见性、重排序？"></a>如何理解并发的三个特性（问题）：原子性、内存可见性、重排序？</h3><p>  这些也是并发程序为什么难写的原因。</p>
<ul>
<li>原子性：原子性是指不可再分的最小操作指令，即单条机器指令，原子性操作任意时刻只能有一个线程，因此是线程安全的。</li>
<li>内存可见性：指当多个线程并发访问共享变量时，一个线程对共享变量的修改，其它线程能够立即看到。<ul>
<li>如果所有的属性都使用了 final 修饰，那么 volatile 也是可以不要的，这就是 final 带来的可见性影响。</li>
<li>在对象的构造方法中设置 final 属性，同时在对象初始化完成前，不要将此对象的引用写入到其他线程可以访问到的地方（不要让引用在构造函数中逸出）。如果这个条件满足，当其他线程看到这个对象的时候，那个线程始终可以看到正确初始化后的对象的 final 属性。</li>
</ul>
</li>
<li>重排序<br>重排序由以下几种机制引起：<ol>
<li>编译器优化：对于没有数据依赖关系的操作，编译器在编译的过程中会进行一定程度的重排。</li>
<li>指令重排序：CPU 优化行为，也是会对不存在数据依赖关系的指令进行一定程度的重排。</li>
<li>内存系统重排序：内存系统没有重排序，但是由于有缓存的存在，使得程序整体上会表现出乱序的行为。</li>
</ol>
</li>
</ul>
<h3 id="线程池的种类，区别和使用场景？"><a href="#线程池的种类，区别和使用场景？" class="headerlink" title="线程池的种类，区别和使用场景？"></a>线程池的种类，区别和使用场景？</h3><h3 id="分析线程池的实现原理和线程的调度过程？"><a href="#分析线程池的实现原理和线程的调度过程？" class="headerlink" title="分析线程池的实现原理和线程的调度过程？"></a>分析线程池的实现原理和线程的调度过程？</h3><h3 id="线程池如何调优，最大数目如何确认？"><a href="#线程池如何调优，最大数目如何确认？" class="headerlink" title="线程池如何调优，最大数目如何确认？"></a>线程池如何调优，最大数目如何确认？</h3><h3 id="数据连接池的工作机制是什么？"><a href="#数据连接池的工作机制是什么？" class="headerlink" title="数据连接池的工作机制是什么？"></a>数据连接池的工作机制是什么？</h3><p>  J2EE 服务器启动时会建立一定数量的池连接，并一直维持不少于此数目的池连接。客户端程序需要连接时，池驱动程序会返回一个未使用的池连接并将其表记为忙。如果当前没有空闲连接，池驱动程序就新建一定数量的连接，新建连接的数量由配置参数决定。当使用的池连接调用完成后，池驱动程序将此连接表记为空闲，其他调用就可以使用这个连接。</p>
<h3 id="可参考："><a href="#可参考：" class="headerlink" title="可参考："></a>可参考：</h3><ol>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247484881&amp;idx=2&amp;sn=b0ecf85cd7c9e543c84e7a9859c20a26" target="_blank" rel="noopener">Java多线程编程核心技术</a></li>
<li><a href="http://www.importnew.com/18459.html" target="_blank" rel="noopener">40个Java多线程问题总结</a></li>
<li><a href="https://javadoop.com/post/java-memory-model" target="_blank" rel="noopener">Java 并发基础之内存模型</a></li>
</ol>
<h2 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h2><h3 id="什么是锁？"><a href="#什么是锁？" class="headerlink" title="什么是锁？"></a>什么是锁？</h3><p>  锁是保证并发共享数据一致性的工具</p>
<h3 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h3><p>  如果一个进程集合里面的每个进程都在等待这个集合中的其他一个进程（包括自身）才能继续往下执行，若无外力他们将无法推进，这种情况就是死锁，处于死锁状态的进程称为死锁进程。</p>
<h3 id="产生死锁的四个条件"><a href="#产生死锁的四个条件" class="headerlink" title="产生死锁的四个条件"></a>产生死锁的四个条件</h3><ol>
<li>互斥：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源</li>
<li>请求与保持：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放</li>
<li>不剥夺：指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放</li>
<li>循环等待：指进程发生死锁后，必然存在一个进程和资源之间的环形链</li>
</ol>
<h3 id="处理死锁的基本方法"><a href="#处理死锁的基本方法" class="headerlink" title="处理死锁的基本方法"></a>处理死锁的基本方法</h3><ol>
<li>预防死锁：通过设置一些限制条件，去破坏产生死锁的必要条件</li>
<li>避免死锁：在资源分配过程中，使用某种方法避免系统进入不安全的状态，从而避免发生死锁</li>
<li>检测死锁：允许死锁的发生，但是通过系统的检测之后，采取一些措施，将死锁清除掉</li>
<li>解除死锁：该方法与检测死锁配合使用</li>
</ol>
<h3 id="Java-中常见的锁有哪些？"><a href="#Java-中常见的锁有哪些？" class="headerlink" title="Java 中常见的锁有哪些？"></a>Java 中常见的锁有哪些？</h3><ul>
<li>阻塞锁<ul>
<li>概念：可以说是让线程进入阻塞状态进行等待，当获得相应的信号（唤醒，时间）时，才可以进入线程的准备就绪状态，准备就绪状态的所有线程，通过竞争，进入运行状态。</li>
</ul>
</li>
<li>按照锁性质分类：<ul>
<li>公平锁 / 非公平锁<ul>
<li>公平锁：指多个线程按照申请锁的顺序来获取锁。<ul>
<li>ReentrantLock 可通过构造函数指定为公平锁</li>
</ul>
</li>
<li>非公平锁：指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。<ul>
<li>实现：ReentrantLock（默认为非公平锁）；Synchronized</li>
<li>优点：吞吐量比公平锁大</li>
</ul>
</li>
</ul>
</li>
<li>独享锁 / 共享锁<ul>
<li>独享锁：指该锁一次只能被一个线程持有。如：ReentrantLock；ReentrantReadWriteLock.WriteLock；Synchronized</li>
<li>共享锁：指该锁可被多个线程持有。如：ReentrantReadWriteLock.ReadLock</li>
</ul>
</li>
<li>互斥锁 / 读写锁<br>上面讲的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。<br>互斥锁在Java中的具体实现就是ReentrantLock<br>读写锁在Java中的具体实现就是ReadWriteLock</li>
<li>悲观锁 / 乐观锁<ul>
<li>乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。<ul>
<li>悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。</li>
<li>乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。</li>
</ul>
</li>
<li>适用场景：<ul>
<li>悲观锁适合写操作非常多的场景</li>
<li>乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升</li>
</ul>
</li>
<li>实现：<ul>
<li>悲观锁在Java中的使用，就是利用各种锁。</li>
<li>乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。</li>
</ul>
</li>
</ul>
</li>
<li>可重入锁  <ul>
<li>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。</li>
<li>jdk里面没有默认的不可重入锁实现类.</li>
<li>实现：ReentrantLock；Synchronized</li>
<li>优点：可一定程度避免死锁</li>
</ul>
</li>
</ul>
</li>
<li>按照设计方案分类：<ul>
<li><a href="http://ifeve.com/java_lock_see1/" target="_blank" rel="noopener">自旋锁</a><ul>
<li>概念：自旋锁是采用让当前线程不停地的在循环体内执行实现的，当循环的条件被其他线程改变时 才能进入临界区。</li>
<li>适用场景：适合于线程竞争不激烈，且锁保持时间短。<br>因为自旋锁只是将当前线程不停地执行循环体，不进行线程状态的改变，所以响应速度更快。但当线程数不停增加时，性能下降明显，因为每个线程都需要执行，占用CPU时间。</li>
</ul>
</li>
<li>锁粗化 / 锁消除<ul>
<li><strong>锁粗化</strong>：如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展到整个操作序列的外部，这样就只需要加锁一次就够了。</li>
<li><strong>锁消除</strong>：指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除主要判定依据来源于逃逸分析的数据支持。锁消除是在编译器级别的事情。</li>
</ul>
</li>
<li>偏向锁 / 轻量级锁 / 重量级锁<br>这三种锁是指锁的状态，并且是针对 Synchronized。在Java 5通过引入锁升级的机制来实现高效Synchronized。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。<ul>
<li><strong>偏向锁</strong>：指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。</li>
<li><strong>轻量级锁</strong>：指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。</li>
<li><strong>重量级锁</strong>：指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。</li>
<li>锁升级是单向的: 无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</li>
</ul>
</li>
<li>分段锁<ul>
<li>分段锁其实是一种锁的设计，并不是具体的一种锁。</li>
<li>分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。</li>
<li>示例：<br>  以 ConcurrentHashMap 来说一下分段锁的含义以及设计思想，ConcurrentHashMap 中的分段锁称为 Segment，它即类似于 HashMap（JDK7与JDK8中HashMap的实现）的结构，即内部拥有一个 Entry 数组，数组中的每个元素又是一个链表；同时又是一个 ReentrantLock（Segment继承了ReentrantLock)。<br>  当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。<br>  但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>方法锁 / 对象锁 / 类锁</li>
<li>线程锁</li>
<li>信号量</li>
</ul>
<ul>
<li>可参考：<ol>
<li><a href="http://blog.csdn.net/nalanmingdian/article/details/77800355" target="_blank" rel="noopener">JAVA锁有哪些种类</a></li>
<li><a href="https://www.cnblogs.com/lxmyhappy/p/7380073.html" target="_blank" rel="noopener">JAVA锁有哪些种类，以及区别</a></li>
</ol>
</li>
</ul>
<h3 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h3><h3 id="重入锁的概念，重入锁为什么可以防止死锁"><a href="#重入锁的概念，重入锁为什么可以防止死锁" class="headerlink" title="重入锁的概念，重入锁为什么可以防止死锁"></a>重入锁的概念，重入锁为什么可以防止死锁</h3><h3 id="如何检查死锁（通过jConsole检查死锁）"><a href="#如何检查死锁（通过jConsole检查死锁）" class="headerlink" title="如何检查死锁（通过jConsole检查死锁）"></a>如何检查死锁（通过jConsole检查死锁）</h3><h3 id="volatile-实现原理（禁止指令重排、刷新内存）？"><a href="#volatile-实现原理（禁止指令重排、刷新内存）？" class="headerlink" title="volatile 实现原理（禁止指令重排、刷新内存）？"></a>volatile 实现原理（禁止指令重排、刷新内存）？</h3><ul>
<li>作用：内存可见性和禁止指令重排序。</li>
<li>volatile 如何解决内存可见性：读一个 volatile 变量之前，需要先使相应的本地缓存失效，这样就必须到主内存读取最新值，写一个 volatile 属性会立即刷入到主内存。</li>
<li>volatile 适用场景：某个属性被多个线程共享，其中有一个线程修改了此属性，其他线程可以立即得到修改后的值。在并发包的源码中，它使用得非常多。</li>
<li>volatile 属性的读写操作都是无锁的，它不能替代 synchronized，因为它没有提供原子性和互斥性。因为无锁，不需要花费时间在获取锁和释放锁上，所以说它是低成本的。</li>
<li>volatile 只能作用于属性，我们用 volatile 修饰属性，这样 compilers 就不会对这个属性做指令重排序。</li>
<li>volatile 提供了可见性，任何一个线程对其的修改将立马对其他线程可见。volatile 属性不会被线程缓存，始终从主存中读取。</li>
<li>volatile 提供了 happens-before 保证，对 volatile 变量 v 的写入 happens-before 所有其他线程后续对 v 的读操作。</li>
<li>volatile 可以使得 long 和 double 的赋值是原子的。</li>
</ul>
<h3 id="synchronized-实现原理（对象监视器）"><a href="#synchronized-实现原理（对象监视器）" class="headerlink" title="synchronized 实现原理（对象监视器）"></a>synchronized 实现原理（对象监视器）</h3><p>  每个对象有一个监视器锁（monitor），当 monitor 被占用时就会处于锁定状态。线程释放锁时其必须是对应的 monitor 的所有者。</p>
<ul>
<li>线程尝试获取 monitor 所有权的过程如下：<ol>
<li>如果 monitor 的进入数为 0，则该线程进入 monitor，然后将进入数设置为 1，该线程即为 monitor 的所有者。</li>
<li>如果线程已经占有该 monitor，只是重新进入，则进入 monitor 的进入数加 1。</li>
<li>如果其他线程已经占用了 monitor，则该线程进入阻塞状态，直到 monitor 的进入数为 0，再重新尝试获取 monitor 的所有权。</li>
</ol>
</li>
<li>线程释放锁的过程如下：<br>线程释放锁时 monitor 的进入数减 1，如果减 1 后进入数为 0，那线程退出 monitor，不再是这个 monitor 的所有者。其他被这个 monitor 阻塞的线程可以尝试去获取这个 monitor 的所有权。</li>
</ul>
<h3 id="synchronized-与-lock-的区别"><a href="#synchronized-与-lock-的区别" class="headerlink" title="synchronized 与 lock 的区别"></a>synchronized 与 lock 的区别</h3><p>  Java 提供了两种锁机制：synchronized 和 lock。</p>
<ul>
<li>用法区别<ul>
<li>synchronized：可以加在方法，特定代码块中</li>
<li>lock：需要显示指定起始位置和终止位置；且在加锁和解锁处需要通过lock()和unlock()显示指出。</li>
</ul>
</li>
<li>性能区别<ul>
<li>synchronized 是托管给 JVM 执行的，而 lock 是 java 写的控制锁的代码。</li>
<li>synchronize 在 Java1.5及之前的版本中性能是低效的，比 Lock 锁效率要低，因为这是一个重量级操作。</li>
<li>synchronize 在 Java1.6进行了很多优化，引入了自旋锁，锁消除，锁粗化，轻量级锁，偏向锁等等，性能得到改善并不比 Lock 差。</li>
</ul>
<ul>
<li>实现机制不同：<ul>
<li>synchronized 原始采用的是CPU悲观锁机制，即线程获得的是独占锁。独占锁意味着其他线程只能依靠阻塞来等待线程释放锁。而在CPU转换线程阻塞时会引起线程上下文切换，当有很多线程竞争锁的时候，会引起CPU频繁的上下文切换导致效率很低。</li>
<li>Lock 用的是乐观锁方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁实现的机制就是CAS操作。</li>
</ul>
</li>
</ul>
</li>
<li>用途区别<br>synchronized 原语和 ReentrantLock 在一般情况下没有什么区别，但是在非常复杂的同步应用中，请考虑使用ReentrantLock，特别是遇到如下情况时：<ol>
<li>某个线程在等待一个锁的控制权的这段时间需要中断。</li>
<li>需要分开处理一些 wait-notify，ReentrantLock 里面的 Condition 应用，能够控制 notify 哪个线程。</li>
<li>具有公平锁功能，每个到来的线程都将排队等候。</li>
</ol>
</li>
</ul>
<h3 id="可参考：Java多线程编程核心技术"><a href="#可参考：Java多线程编程核心技术" class="headerlink" title="可参考：Java多线程编程核心技术"></a>可参考：<a href="http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247484881&amp;idx=2&amp;sn=b0ecf85cd7c9e543c84e7a9859c20a26" target="_blank" rel="noopener">Java多线程编程核心技术</a></h3><h2 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h2><h3 id="Java-并发体系思维导图"><a href="#Java-并发体系思维导图" class="headerlink" title="Java 并发体系思维导图"></a>Java 并发体系思维导图</h3><p>  <img src="http://cmsblogs.com/wp-content/images/share/chenssy_juc_201712.png" alt="Java 并发体系思维导图"></p>
<h3 id="AQS-同步队列"><a href="#AQS-同步队列" class="headerlink" title="AQS 同步队列"></a>AQS 同步队列</h3><h3 id="LockSupport工具"><a href="#LockSupport工具" class="headerlink" title="LockSupport工具"></a>LockSupport工具</h3><h3 id="Condition接口及其实现原理"><a href="#Condition接口及其实现原理" class="headerlink" title="Condition接口及其实现原理"></a>Condition接口及其实现原理</h3><h3 id="Fork-Join框架的理解"><a href="#Fork-Join框架的理解" class="headerlink" title="Fork/Join框架的理解"></a>Fork/Join框架的理解</h3><h3 id="分段锁的原理-锁力度减小的思考"><a href="#分段锁的原理-锁力度减小的思考" class="headerlink" title="分段锁的原理,锁力度减小的思考"></a>分段锁的原理,锁力度减小的思考</h3><h3 id="八种阻塞队列以及各个阻塞队列的特性"><a href="#八种阻塞队列以及各个阻塞队列的特性" class="headerlink" title="八种阻塞队列以及各个阻塞队列的特性"></a>八种阻塞队列以及各个阻塞队列的特性</h3><h3 id="Java中的队列都有哪些，有什么区别？"><a href="#Java中的队列都有哪些，有什么区别？" class="headerlink" title="Java中的队列都有哪些，有什么区别？"></a><a href="https://mp.weixin.qq.com/s?__biz=MzAwMTE3MDY4MQ==&amp;mid=2652433302&amp;idx=1&amp;sn=2c51d1990fbdd2c917bc3cdc00508a72" target="_blank" rel="noopener">Java中的队列都有哪些，有什么区别？</a></h3><h3 id="常见的原子操作类"><a href="#常见的原子操作类" class="headerlink" title="常见的原子操作类"></a>常见的原子操作类</h3><h3 id="Java-8并法包下常见的并发类"><a href="#Java-8并法包下常见的并发类" class="headerlink" title="Java 8并法包下常见的并发类"></a>Java 8并法包下常见的并发类</h3><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><ul>
<li>JVM 思维导图<br><img src="http://fakerblog-wordpress.stor.sinaapp.com/uploads/2014/07/1232.jpg" alt="JVM 思维导图"></li>
</ul>
<ul>
<li>JVM 运行时内存区域划分<ol>
<li><strong>程序计数器</strong>(Program Counter Register)<br>用来指示 执行哪条指令的</li>
<li><strong>Java 栈</strong>(VM Stack)或称 Java 虚拟机栈<ul>
<li>Java栈是Java方法执行的内存模型</li>
</ul>
<ul>
<li>Java栈中存放的是一个个的栈帧，每个栈帧对应一个被调用的方法。<br>在栈帧中包括：<ul>
<li>局部变量表(Local Variables)</li>
<li>操作数栈(Operand Stack)</li>
<li>指向当前方法所属的类的运行时常量池（运行时常量池的概念在方法区部分会谈到）的引用(Reference to runtime constant pool)</li>
<li>方法返回地址(Return Address)</li>
<li>一些额外的附加信息</li>
</ul>
</li>
</ul>
</li>
<li><strong>本地方法栈</strong>(Native Method Stack)</li>
<li><strong>方法区</strong>(Method Area)<br>存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。</li>
<li><strong>堆</strong>(Heap)<br>堆是用来存储对象本身以及数组（当然，数组引用是存放在Java栈中的）的。</li>
</ol>
</li>
</ul>
<h3 id="什么是类的加载"><a href="#什么是类的加载" class="headerlink" title="什么是类的加载"></a>什么是类的加载</h3><ul>
<li>类的加载是指将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。</li>
<li>类加载的最终产品是位于堆区中的 Class 对象，Class 对象封装了类在方法区内的数据结构，并且向 Java 程序员提供了访问方法区内的数据结构的接口。<h3 id="class-文件加载方式"><a href="#class-文件加载方式" class="headerlink" title="class 文件加载方式"></a>class 文件加载方式</h3></li>
<li>从本地系统中直接加载</li>
<li>通过网络下载.class文件</li>
<li>从zip，jar等归档文件中加载.class文件</li>
<li>从专有数据库中提取.class文件</li>
<li>将Java源文件动态编译为.class文件<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3></li>
</ul>
<ul>
<li>从 JVM 角度只有两种类加载器：<ul>
<li>启动类加载器：是虚拟机自身的一部分，使用 C++ 实现。</li>
<li>所有其他的类加载器：全继承自 java.lang.ClassLoader，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。由 Java 实现。</li>
</ul>
</li>
<li>从 Java 开发人员的角度，类加载器分三类：<ol>
<li><strong>启动类加载器</strong>：Bootstrap ClassLoader，负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被 -Xbootclasspath 参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被Java程序直接引用的。</li>
<li><strong>扩展类加载器</strong>：Extension ClassLoader，该加载器由 sun.misc.Launcher$ExtClassLoader 实现，它负责加载 JDK\jre\lib\ext 目录中，或者由 java.ext.dirs 系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。</li>
<li><strong>应用程序类加载器</strong>：Application ClassLoader，该类加载器由 sun.misc.Launcher$AppClassLoader 来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。<h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3></li>
</ol>
</li>
<li>加载：查找并加载类的二进制数据，在 Java 堆中也创建一个 java.lang.Class 类的对象<ul>
<li>类加载的时机：类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class 文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误</li>
</ul>
</li>
<li>连接<br>又包含三块内容：<ul>
<li>验证：文件格式、元数据、字节码、符号引用验证。确保被加载的类的正确性。</li>
<li>准备：为类的静态变量分配内存，并将其初始化为默认值</li>
<li>解析：把类中的符号引用转换为直接引用</li>
</ul>
</li>
<li>初始化：为类的静态变量赋予正确的初始值<ul>
<li>类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：<ul>
<li>创建类的实例，也就是 new 的方式</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射（如Class.forName(“com.mysql.jdbc.Driver”)）</li>
<li>初始化某个类的子类，则其父类也会被初始化</li>
<li>Java虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exe命令来运行某个主类</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>使用：new 出对象，程序中使用</li>
<li>卸载：执行垃圾回收<h3 id="JVM-类加载机制"><a href="#JVM-类加载机制" class="headerlink" title="JVM 类加载机制"></a>JVM 类加载机制</h3></li>
</ul>
<ul>
<li><strong>父类委托</strong>：先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类<ul>
<li>双亲委派模型工作流程：<br>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</li>
<li>双亲委派模型意义：<ul>
<li>系统类防止内存中出现多份同样的字节码</li>
<li>保证Java程序安全稳定运行</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>全盘负责</strong>：当一个类加载器负责加载某个 Class 时，该 Class 所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</li>
<li><strong>缓存机制</strong>：缓存机制将会保证所有加载过的 Class 都会被缓存，当程序中需要使用某个 Class 时，类加载器先从缓存区寻找该 Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成 Class 对象，存入缓存区。这就是为什么修改了 Class 后，必须重启 JVM，程序的修改才会生效。</li>
</ul>
<h3 id="什么时候发生-GC。"><a href="#什么时候发生-GC。" class="headerlink" title="什么时候发生 GC。"></a>什么时候发生 GC。</h3><p>  Java 中的堆是 GC 的主要区域。GC 分为两种：Minor GC、FullGC (或称为 Major GC)。<br>  Minor GC 是发生在新生代中的垃圾收集动作，所采用的是复制算法。<br>  Full GC 是发生在老年代的垃圾收集动作，所采用的是标记-清除算法。</p>
<ul>
<li><p>Minor GC(Young GC)</p>
<ul>
<li>从年轻代空间（包括 Eden 和 Survivor 区域）回收内存被称为 Minor GC</li>
<li>当 JVM 无法为一个新的对象分配空间时会触发 Minor GC，比如当 Eden 区满了。所以分配率越高，越频繁执行 Minor GC。</li>
<li>Minor GC 都会触发“全世界的暂停（stop-the-world）”</li>
<li>执行 Minor GC 操作时，不会影响到永久代</li>
</ul>
<ul>
<li>触发条件：当Eden区满时，触发 Minor GC。</li>
</ul>
</li>
<li><p>Full GC：清理整个堆空间—包括年轻代和老年代</p>
<ul>
<li>触发条件：<ol>
<li>调用System.gc时，系统建议执行Full GC，但是不必然执行</li>
<li>老年代空间不足</li>
<li>方法去空间不足</li>
<li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li>
<li>由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li>
</ol>
</li>
</ul>
</li>
<li><p>堆大小 = 新生代 + 老年代<br>JDK1.6 默认：新生代(Young)与老年代(Old)的比例为 1:2 (该值可以通过参数 –XX:NewRatio 来指定)<br>JDK1.6 默认：Edem : from : to(from) = 8 : 1 : 1 (可以通过参数 –XX:SurvivorRatio 来设定)<br>JVM 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块 Survivor 区域是空闲着的。</p>
</li>
</ul>
<h3 id="Minor-GC-过程"><a href="#Minor-GC-过程" class="headerlink" title="Minor GC 过程"></a>Minor GC 过程</h3><ol>
<li>对象出生在 Eden (或一个 Survivor 区域，这里假设是 from 区域)</li>
<li>经一次 Minor GC 后，若对象还活着，且能够被另外一块 Survivor 区域所容纳(这里为 to 区域，即 to 区域有足够的内存空间来存储 Eden 和 from 区域中存活的对象)，则使用复制算法将这些仍然还存活的对象复制到另外一块 Survivor 区域 (即 to 区域) 中</li>
<li>然后清理所使用过的 Eden 以及 Survivor 区域 ( 即from 区域 )，并且将这些对象的年龄设置为 1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1。</li>
<li>当对象的年龄达到某个值时 ( 默认是 15 岁，可以通过参数 -XX:MaxTenuringThreshold 来设定)，这些对象就会成为老年代。但这也不是一定的，对于一些较大的对象 ( 即需要分配一块较大的连续内存空间 ) 则是直接进入到老年代。</li>
</ol>
<h3 id="Java-中会存在内存泄漏吗？"><a href="#Java-中会存在内存泄漏吗？" class="headerlink" title="Java 中会存在内存泄漏吗？"></a>Java 中会存在内存泄漏吗？</h3><p>  会。<br>  有两类主要的Java内存泄漏：</p>
<ul>
<li><strong>非必要的对象引用</strong><br>Java代码常常保留对于不再需要的对象引用，这阻止了垃圾收集器对这部分对象的回收工作。Java对象通常被其他对象包含引用，为此一个单一对象可以保持整个对象树在内存中，于是导致了如下问题:<ol>
<li>在向数组添加对象以后遗漏了对于他们的处理</li>
<li>直到你再次使用对象的时候都不释放引用。比如一个菜单指令可以插件一个对象实例引用并且不释放便于以后再次调用的时候使用，但是也许永远不会发生。</li>
<li>在其他引用依然需要旧有状态的时候贸然修改对象状态。比如当你为了在一个文本文件里面保存一些属性而使用一个数组，诸如”字符个数”等字段在不再需要的时候依然保留在内存当中.</li>
<li>允许一个长久执行的线程所引用的对象。设置引用为 NULL 也无济于事，在线程退出和空闲之前，对象不会被收集释放</li>
</ol>
</li>
<li><strong>未释放的系统资源</strong><br>Java方法可以定位 Java 实例以外的堆内存，诸如针对视窗和位图的内存资源。Java常常通过JNI(Java Native Interface)调用C/C++子程序定位这些资源。</li>
</ul>
<h3 id="内存溢出-OOM-和堆栈溢出-SOE-的示例及原因、如何排查与解决"><a href="#内存溢出-OOM-和堆栈溢出-SOE-的示例及原因、如何排查与解决" class="headerlink" title="内存溢出 OOM 和堆栈溢出 SOE 的示例及原因、如何排查与解决"></a>内存溢出 OOM 和堆栈溢出 SOE 的示例及原因、如何排查与解决</h3><h3 id="如何判断对象是否可以回收或存活"><a href="#如何判断对象是否可以回收或存活" class="headerlink" title="如何判断对象是否可以回收或存活"></a>如何判断对象是否可以回收或存活</h3><h3 id="常见的GC回收算法及其含义"><a href="#常见的GC回收算法及其含义" class="headerlink" title="常见的GC回收算法及其含义"></a>常见的GC回收算法及其含义</h3><h3 id="常见的JVM性能监控和故障处理工具类：jps、jstat、jmap、jinfo、jconsole等"><a href="#常见的JVM性能监控和故障处理工具类：jps、jstat、jmap、jinfo、jconsole等" class="headerlink" title="常见的JVM性能监控和故障处理工具类：jps、jstat、jmap、jinfo、jconsole等"></a>常见的JVM性能监控和故障处理工具类：jps、jstat、jmap、jinfo、jconsole等</h3><h3 id="JVM如何设置参数"><a href="#JVM如何设置参数" class="headerlink" title="JVM如何设置参数"></a>JVM如何设置参数</h3><h3 id="JVM性能调优"><a href="#JVM性能调优" class="headerlink" title="JVM性能调优"></a>JVM性能调优</h3><h3 id="可参考：-1"><a href="#可参考：-1" class="headerlink" title="可参考："></a>可参考：</h3><ol>
<li><a href="http://www.54tianzhisheng.cn/2018/02/28/Java-Memory-Model/" target="_blank" rel="noopener">深入理解 Java 内存模型读书笔记</a></li>
<li><a href="http://www.ityouknow.com/java/2017/03/01/jvm-overview.html" target="_blank" rel="noopener">jvm知识点总览</a></li>
<li><a href="http://www.cnblogs.com/ityouknow/p/5603287.html" target="_blank" rel="noopener">java类的加载机制</a></li>
</ol>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="常见的设计模式"><a href="#常见的设计模式" class="headerlink" title="常见的设计模式"></a>常见的设计模式</h3><h3 id="设计模式的的六大原则及其含义"><a href="#设计模式的的六大原则及其含义" class="headerlink" title="设计模式的的六大原则及其含义"></a>设计模式的的六大原则及其含义</h3><h3 id="常见的单例模式以及各种实现方式的优缺点，哪一种最好，手写常见的单利模式"><a href="#常见的单例模式以及各种实现方式的优缺点，哪一种最好，手写常见的单利模式" class="headerlink" title="常见的单例模式以及各种实现方式的优缺点，哪一种最好，手写常见的单利模式"></a>常见的单例模式以及各种实现方式的优缺点，哪一种最好，手写常见的单利模式</h3><h3 id="设计模式在实际场景中的应用"><a href="#设计模式在实际场景中的应用" class="headerlink" title="设计模式在实际场景中的应用"></a>设计模式在实际场景中的应用</h3><h3 id="Spring中用到了哪些设计模式"><a href="#Spring中用到了哪些设计模式" class="headerlink" title="Spring中用到了哪些设计模式"></a>Spring中用到了哪些设计模式</h3><h3 id="MyBatis中用到了哪些设计模式"><a href="#MyBatis中用到了哪些设计模式" class="headerlink" title="MyBatis中用到了哪些设计模式"></a>MyBatis中用到了哪些设计模式</h3><h3 id="你项目中有使用哪些设计模式"><a href="#你项目中有使用哪些设计模式" class="headerlink" title="你项目中有使用哪些设计模式"></a>你项目中有使用哪些设计模式</h3><h3 id="说说常用开源框架中设计模式使用分析"><a href="#说说常用开源框架中设计模式使用分析" class="headerlink" title="说说常用开源框架中设计模式使用分析"></a>说说常用开源框架中设计模式使用分析</h3><h3 id="动态代理很重要！！！"><a href="#动态代理很重要！！！" class="headerlink" title="动态代理很重要！！！"></a>动态代理很重要！！！</h3><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="树（二叉查找树、平衡二叉树、红黑树、B树、B-树）"><a href="#树（二叉查找树、平衡二叉树、红黑树、B树、B-树）" class="headerlink" title="树（二叉查找树、平衡二叉树、红黑树、B树、B+树）"></a>树（二叉查找树、平衡二叉树、红黑树、B树、B+树）</h3><h3 id="深度有限算法、广度优先算法"><a href="#深度有限算法、广度优先算法" class="headerlink" title="深度有限算法、广度优先算法"></a>深度有限算法、广度优先算法</h3><h3 id="克鲁斯卡尔算法、普林母算法、迪克拉斯算法"><a href="#克鲁斯卡尔算法、普林母算法、迪克拉斯算法" class="headerlink" title="克鲁斯卡尔算法、普林母算法、迪克拉斯算法"></a>克鲁斯卡尔算法、普林母算法、迪克拉斯算法</h3><h3 id="什么是一致性Hash及其原理、Hash环问题"><a href="#什么是一致性Hash及其原理、Hash环问题" class="headerlink" title="什么是一致性Hash及其原理、Hash环问题"></a>什么是一致性Hash及其原理、Hash环问题</h3><h3 id="常见的排序算法和查找算法：快排、折半查找、堆排序等"><a href="#常见的排序算法和查找算法：快排、折半查找、堆排序等" class="headerlink" title="常见的排序算法和查找算法：快排、折半查找、堆排序等"></a>常见的排序算法和查找算法：快排、折半查找、堆排序等</h3><p>  快排算法：<br>    //使用快速排序方法对a[0:n-1]排序<br>    从a[0:n-1]中选择一个元素作为middle，该元素为支点<br>    把余下的元素分割为两段left和right，使得left中的元素都小于等于支点，而right中的元素都大于等于支点<br>    递归地使用快速排序方法对left进行排序<br>    递归地使用快速排序方法对right进行排序<br>    所得结果为left+middle+right</p>
<h2 id="网络-IO-基础"><a href="#网络-IO-基础" class="headerlink" title="网络 / IO 基础"></a>网络 / IO 基础</h2><h3 id="BIO、NIO、AIO的概念"><a href="#BIO、NIO、AIO的概念" class="headerlink" title="BIO、NIO、AIO的概念"></a>BIO、NIO、AIO的概念</h3><p>  可参考：<a href="https://tech.meituan.com/nio.html" target="_blank" rel="noopener">Java NIO浅析</a></p>
<h3 id="什么是长连接和短连接"><a href="#什么是长连接和短连接" class="headerlink" title="什么是长连接和短连接"></a>什么是长连接和短连接</h3><h3 id="Http1-0-和-2-0-相比有什么区别，可参考Http-2-0"><a href="#Http1-0-和-2-0-相比有什么区别，可参考Http-2-0" class="headerlink" title="Http1.0 和 2.0 相比有什么区别，可参考Http 2.0"></a>Http1.0 和 2.0 相比有什么区别，可参考<a href="http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247484611&amp;idx=1&amp;sn=66c875392eedff8150633ddcd5d83e7a" target="_blank" rel="noopener">Http 2.0</a></h3><h3 id="Https的基本概念"><a href="#Https的基本概念" class="headerlink" title="Https的基本概念"></a>Https的基本概念</h3><h3 id="三次握手和四次挥手、为什么挥手需要四次"><a href="#三次握手和四次挥手、为什么挥手需要四次" class="headerlink" title="三次握手和四次挥手、为什么挥手需要四次"></a>三次握手和四次挥手、为什么挥手需要四次</h3><h3 id="从游览器中输入URL到页面加载的发生了什么？可参考从输入URL到页面加载发生了什么"><a href="#从游览器中输入URL到页面加载的发生了什么？可参考从输入URL到页面加载发生了什么" class="headerlink" title="从游览器中输入URL到页面加载的发生了什么？可参考从输入URL到页面加载发生了什么"></a>从游览器中输入URL到页面加载的发生了什么？可参考<a href="http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247483724&amp;idx=1&amp;sn=e58dd30d124971c795584e8673d6cc71" target="_blank" rel="noopener">从输入URL到页面加载发生了什么</a></h3><h1 id="数据存储和消息队列"><a href="#数据存储和消息队列" class="headerlink" title="数据存储和消息队列"></a>数据存储和消息队列</h1><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="MySQL-索引使用的注意事项"><a href="#MySQL-索引使用的注意事项" class="headerlink" title="MySQL 索引使用的注意事项"></a>MySQL 索引使用的注意事项</h3><h3 id="DDL、DML、DCL分别指什么"><a href="#DDL、DML、DCL分别指什么" class="headerlink" title="DDL、DML、DCL分别指什么"></a>DDL、DML、DCL分别指什么</h3><ul>
<li>DDL：data manipulation language 数据操纵语言<br>主要用来对数据库的数据进行一些操作，如： SELECT、UPDATE、INSERT、DELETE。</li>
<li>DML：data definition language 数据库定义语言<br>如：CREATE、ALTER、DROP等</li>
<li>DCL：Data Control Language 数据库控制语言<br>用来设置或更改数据库用户或角色权限的语句，如 grant,deny,revoke等语句</li>
</ul>
<h3 id="explain-命令"><a href="#explain-命令" class="headerlink" title="explain 命令"></a>explain 命令</h3><h3 id="left-join，right-join，inner-join"><a href="#left-join，right-join，inner-join" class="headerlink" title="left join，right join，inner join"></a>left join，right join，inner join</h3><h3 id="数据库事物-ACID"><a href="#数据库事物-ACID" class="headerlink" title="数据库事物 ACID"></a>数据库事物 ACID</h3><p>  （原子性、一致性、隔离性、持久性）</p>
<h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><p>  （读未提交、读以提交、可重复读、可序列化读）</p>
<h3 id="脏读、幻读、不可重复读"><a href="#脏读、幻读、不可重复读" class="headerlink" title="脏读、幻读、不可重复读"></a>脏读、幻读、不可重复读</h3><h3 id="数据库的几大范式"><a href="#数据库的几大范式" class="headerlink" title="数据库的几大范式"></a>数据库的几大范式</h3><h3 id="数据库常见的命令"><a href="#数据库常见的命令" class="headerlink" title="数据库常见的命令"></a>数据库常见的命令</h3><h3 id="说说分库与分表设计"><a href="#说说分库与分表设计" class="headerlink" title="说说分库与分表设计"></a>说说分库与分表设计</h3><h3 id="分库与分表带来的分布式困境与应对之策（如何解决分布式下的分库分表，全局表？）"><a href="#分库与分表带来的分布式困境与应对之策（如何解决分布式下的分库分表，全局表？）" class="headerlink" title="分库与分表带来的分布式困境与应对之策（如何解决分布式下的分库分表，全局表？）"></a>分库与分表带来的分布式困境与应对之策（如何解决分布式下的分库分表，全局表？）</h3><h3 id="说说-SQL-优化之道。可参考19个MySQL性能优化要点解析"><a href="#说说-SQL-优化之道。可参考19个MySQL性能优化要点解析" class="headerlink" title="说说 SQL 优化之道。可参考19个MySQL性能优化要点解析"></a>说说 SQL 优化之道。可参考<a href="http://blog.csdn.net/xlgen157387/article/details/50735269" target="_blank" rel="noopener">19个MySQL性能优化要点解析</a></h3><h3 id="MySQL遇到的死锁问题、如何排查与解决"><a href="#MySQL遇到的死锁问题、如何排查与解决" class="headerlink" title="MySQL遇到的死锁问题、如何排查与解决"></a>MySQL遇到的死锁问题、如何排查与解决</h3><h3 id="存储引擎的-InnoDB与MyISAM区别，优缺点，使用场景"><a href="#存储引擎的-InnoDB与MyISAM区别，优缺点，使用场景" class="headerlink" title="存储引擎的 InnoDB与MyISAM区别，优缺点，使用场景"></a>存储引擎的 InnoDB与MyISAM区别，优缺点，使用场景</h3><h3 id="索引类别（B-树索引、全文索引、哈希索引）、索引的原理"><a href="#索引类别（B-树索引、全文索引、哈希索引）、索引的原理" class="headerlink" title="索引类别（B+树索引、全文索引、哈希索引）、索引的原理"></a>索引类别（B+树索引、全文索引、哈希索引）、索引的原理</h3><h3 id="什么是自适应哈希索引（AHI）"><a href="#什么是自适应哈希索引（AHI）" class="headerlink" title="什么是自适应哈希索引（AHI）"></a>什么是自适应哈希索引（AHI）</h3><h3 id="为什么要用-B-tree-作为MySQL索引的数据结构"><a href="#为什么要用-B-tree-作为MySQL索引的数据结构" class="headerlink" title="为什么要用 B+tree 作为MySQL索引的数据结构"></a>为什么要用 B+tree 作为MySQL索引的数据结构</h3><h3 id="聚集索引与非聚集索引的区别"><a href="#聚集索引与非聚集索引的区别" class="headerlink" title="聚集索引与非聚集索引的区别"></a>聚集索引与非聚集索引的区别</h3><h3 id="遇到过索引失效的情况没，什么时候可能会出现，如何解决"><a href="#遇到过索引失效的情况没，什么时候可能会出现，如何解决" class="headerlink" title="遇到过索引失效的情况没，什么时候可能会出现，如何解决"></a>遇到过索引失效的情况没，什么时候可能会出现，如何解决</h3><h3 id="limit-20000-加载很慢怎么解决"><a href="#limit-20000-加载很慢怎么解决" class="headerlink" title="limit 20000 加载很慢怎么解决"></a>limit 20000 加载很慢怎么解决</h3><h3 id="如何选择合适的分布式主键方案"><a href="#如何选择合适的分布式主键方案" class="headerlink" title="如何选择合适的分布式主键方案"></a>如何选择合适的分布式主键方案</h3><h3 id="选择合适的数据存储方案"><a href="#选择合适的数据存储方案" class="headerlink" title="选择合适的数据存储方案"></a>选择合适的数据存储方案</h3><h3 id="常见的几种分布式ID的设计方案"><a href="#常见的几种分布式ID的设计方案" class="headerlink" title="常见的几种分布式ID的设计方案"></a>常见的几种分布式ID的设计方案</h3><h3 id="常见的数据库优化方案，在你的项目中数据库如何进行优化的"><a href="#常见的数据库优化方案，在你的项目中数据库如何进行优化的" class="headerlink" title="常见的数据库优化方案，在你的项目中数据库如何进行优化的"></a>常见的数据库优化方案，在你的项目中数据库如何进行优化的</h3><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="Redis-有哪些数据类型，可参考Redis常见的5种不同的数据类型详解"><a href="#Redis-有哪些数据类型，可参考Redis常见的5种不同的数据类型详解" class="headerlink" title="Redis 有哪些数据类型，可参考Redis常见的5种不同的数据类型详解"></a>Redis 有哪些数据类型，可参考<a href="https://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247483987&amp;idx=1&amp;sn=5c5e4cd5bc73a7e6f84e5d6adfab0935" target="_blank" rel="noopener">Redis常见的5种不同的数据类型详解</a></h3><h3 id="Redis-内部结构"><a href="#Redis-内部结构" class="headerlink" title="Redis 内部结构"></a>Redis 内部结构</h3><h3 id="Redis-使用场景"><a href="#Redis-使用场景" class="headerlink" title="Redis 使用场景"></a>Redis 使用场景</h3><h3 id="Redis-持久化机制，可参考使用快照和AOF将Redis数据持久化到硬盘中"><a href="#Redis-持久化机制，可参考使用快照和AOF将Redis数据持久化到硬盘中" class="headerlink" title="Redis 持久化机制，可参考使用快照和AOF将Redis数据持久化到硬盘中"></a>Redis 持久化机制，可参考<a href="http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247483992&amp;idx=1&amp;sn=8f554bc490c4db1a78a30144f873e911" target="_blank" rel="noopener">使用快照和AOF将Redis数据持久化到硬盘中</a></h3><h3 id="Redis-集群方案与实现"><a href="#Redis-集群方案与实现" class="headerlink" title="Redis 集群方案与实现"></a>Redis 集群方案与实现</h3><h3 id="Redis-为什么是单线程的？"><a href="#Redis-为什么是单线程的？" class="headerlink" title="Redis 为什么是单线程的？"></a>Redis 为什么是单线程的？</h3><h3 id="缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级"><a href="#缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级" class="headerlink" title="缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级"></a>缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级</h3><h3 id="使用缓存的合理性问题"><a href="#使用缓存的合理性问题" class="headerlink" title="使用缓存的合理性问题"></a>使用缓存的合理性问题</h3><h3 id="Redis-常见的回收策略"><a href="#Redis-常见的回收策略" class="headerlink" title="Redis 常见的回收策略"></a>Redis 常见的回收策略</h3><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>  MQ 是一个互联网架构中常见的解耦利器<br>  <img src="http://neoremind.com/wp-content/uploads/MQ_mind2.png" alt="消息队列思维导图"></p>
<h3 id="消息队列的使用场景"><a href="#消息队列的使用场景" class="headerlink" title="消息队列的使用场景"></a>消息队列的使用场景</h3><ul>
<li>什么时候使用 MQ？<ul>
<li>数据驱动的任务依赖</li>
<li>上游不关心多下游执行结果<br>上游需要关注执行结果时要用“调用”，上游不关注执行结果时，就可以使用MQ了。</li>
<li>上游关注执行结果，但执行时间很长（异步返回执行时间长）<br>有时候上游需要关注执行结果，但执行结果时间很长（典型的是调用离线处理，或者跨公网调用），也经常使用回调网关+MQ来解耦。</li>
</ul>
</li>
<li>什么时候不使用 MQ？<ul>
<li>上游实时关注执行结果</li>
</ul>
</li>
</ul>
<h3 id="消息的重发补偿解决思路"><a href="#消息的重发补偿解决思路" class="headerlink" title="消息的重发补偿解决思路"></a>消息的重发补偿解决思路</h3><h3 id="消息的幂等性解决思路"><a href="#消息的幂等性解决思路" class="headerlink" title="消息的幂等性解决思路"></a>消息的幂等性解决思路</h3><h3 id="消息的堆积解决思路"><a href="#消息的堆积解决思路" class="headerlink" title="消息的堆积解决思路"></a>消息的堆积解决思路</h3><h3 id="自己如何实现消息队列"><a href="#自己如何实现消息队列" class="headerlink" title="自己如何实现消息队列"></a>自己如何实现消息队列</h3><h3 id="如何保证消息的有序性"><a href="#如何保证消息的有序性" class="headerlink" title="如何保证消息的有序性"></a>如何保证消息的有序性</h3><h3 id="可参考：-2"><a href="#可参考：-2" class="headerlink" title="可参考："></a>可参考：</h3><ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651960012&amp;idx=1&amp;sn=c6af5c79ecead98daa4d742e5ad20ce5" target="_blank" rel="noopener">到底什么时候该使用 MQ？</a></li>
<li><a href="http://neoremind.com/2018/03/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%8A%80%E6%9C%AF%E7%82%B9%E6%A2%B3%E7%90%86/" target="_blank" rel="noopener">消息队列技术点梳理（思维导图版）</a></li>
</ul>
<h1 id="开源框架和容器"><a href="#开源框架和容器" class="headerlink" title="开源框架和容器"></a>开源框架和容器</h1><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><h3 id="什么是-Servlet？"><a href="#什么是-Servlet？" class="headerlink" title="什么是 Servlet？"></a>什么是 Servlet？</h3><p>  Servlet 是一些遵从 Java Servlet API 的 Java 类（实现 Servlet 接口的类），这些Java类可以响应请求。</p>
<h3 id="Servlet-的生命周期"><a href="#Servlet-的生命周期" class="headerlink" title="Servlet 的生命周期"></a>Servlet 的生命周期</h3><ul>
<li>初始化- init()</li>
<li>请求处理 - service()</li>
<li>卸载 Servlet - destroy()</li>
</ul>
<h3 id="转发与重定向的区别"><a href="#转发与重定向的区别" class="headerlink" title="转发与重定向的区别"></a>转发与重定向的区别</h3><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="什么是-Spring，你对-Spring-的理解？"><a href="#什么是-Spring，你对-Spring-的理解？" class="headerlink" title="什么是 Spring，你对 Spring 的理解？"></a>什么是 Spring，你对 Spring 的理解？</h3><ul>
<li>Spring是一个轻型容器(light-weight container)，其核心是Bean工厂(Bean Factory)，用以构造我们所需要的M(Model)。</li>
<li>在此基础之上，Spring 提供了AOP（Aspect-Oriented Programming, 面向层面的编程）的实现，用它来提供声明式事务、安全等服务；</li>
<li>对 Bean 工厂的扩展ApplicationContext更加方便我们实现J2EE的应用；</li>
<li>DAO/ORM 的实现方便我们进行数据库的开发；</li>
<li>Web MVC 和 Spring Web 提供了 Java Web 应用的框架或与其他流行的 Web 框架进行集成。</li>
</ul>
<h3 id="BeanFactory-和-FactoryBean？"><a href="#BeanFactory-和-FactoryBean？" class="headerlink" title="BeanFactory 和 FactoryBean？"></a>BeanFactory 和 FactoryBean？</h3><h3 id="BeanFactory-和-ApplicationContext-有什么区别"><a href="#BeanFactory-和-ApplicationContext-有什么区别" class="headerlink" title="BeanFactory 和 ApplicationContext 有什么区别"></a>BeanFactory 和 ApplicationContext 有什么区别</h3><h3 id="Spring-Bean-的生命周期，如何被管理的？"><a href="#Spring-Bean-的生命周期，如何被管理的？" class="headerlink" title="Spring Bean 的生命周期，如何被管理的？"></a>Spring Bean 的生命周期，如何被管理的？</h3><ol>
<li>Spring 容器 从XML 文件中读取 Bean 的定义，并实例化bean。</li>
<li>Spring 根据 Bean 的定义填充所有的属性。</li>
<li>如果 Bean 实现了BeanNameAware 接口，Spring 传递 Bean 的ID 到 setBeanName方法。</li>
<li>如果 Bean 实现了 BeanFactoryAware 接口， Spring 传递 Beanfactory 给 setBeanFactory 方法。</li>
<li>如果有任何与 Bean 相关联的 BeanPostProcessors，Spring 会在 postProcesserBeforeInitialization()方法内调用它们。</li>
<li>如果 Bean 实现 IntializingBean 了，调用它的 afterPropertySet 方法，如果 Bean 声明了初始化方法，调用此初始化方法。</li>
<li>如果有 BeanPostProcessors 和 Bean 关联，这些 Bean 的 postProcessAfterInitialization() 方法将被调用。</li>
<li>如果 Bean 实现了 DisposableBean，它将调用 destroy()方法。</li>
</ol>
<h3 id="Spring-IOC-如何实现。可参考三条路线告诉你如何掌握Spring-IoC容器的核心原理"><a href="#Spring-IOC-如何实现。可参考三条路线告诉你如何掌握Spring-IoC容器的核心原理" class="headerlink" title="Spring IOC 如何实现。可参考三条路线告诉你如何掌握Spring IoC容器的核心原理"></a>Spring IOC 如何实现。可参考<a href="http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247484890&amp;idx=1&amp;sn=b0d0f5013021b86441e1abd37c6724e7" target="_blank" rel="noopener">三条路线告诉你如何掌握Spring IoC容器的核心原理</a></h3><h3 id="Spring中Bean的作用域，默认的是哪一个？-Singleton"><a href="#Spring中Bean的作用域，默认的是哪一个？-Singleton" class="headerlink" title="Spring中Bean的作用域，默认的是哪一个？ Singleton"></a>Spring中Bean的作用域，默认的是哪一个？ Singleton</h3><h3 id="Spring-IOC-的理解，其初始化过程？"><a href="#Spring-IOC-的理解，其初始化过程？" class="headerlink" title="Spring IOC 的理解，其初始化过程？"></a>Spring IOC 的理解，其初始化过程？</h3><p>  IOC:控制反转也叫依赖注入，IOC利用java反射机制，AOP利用代理模式。所谓控制反转是指，本来被调用者的实例是有调用者来创建的，这样的缺点是耦合性太强，IOC则是统一交给spring来管理创建，将对象交给容器管理，你只需要在spring配置文件总配置相应的bean，以及设置相关的属性，让spring容器来生成类的实例对象以及管理对象。在spring容器启动的时候，spring会把你在配置文件中配置的bean都初始化好，然后在你需要调用的时候，就把它已经初始化好的那些bean分配给你需要调用这些bean的类。</p>
<h3 id="说说-Spring-AOP"><a href="#说说-Spring-AOP" class="headerlink" title="说说 Spring AOP"></a>说说 Spring AOP</h3><p>  面向切面编程（AOP）完善spring的依赖注入（DI），面向切面编程在spring中主要表现为两个方面</p>
<ol>
<li>面向切面编程提供声明式事务管理</li>
<li>spring支持用户自定义的切面<br>AOP：面向切面，是一种编程思想，OOP的延续。将系统中非核心的业务提取出来，进行单独处理。比如事务、日志和安全等。<h3 id="Spring-AOP-实现原理"><a href="#Spring-AOP-实现原理" class="headerlink" title="Spring AOP 实现原理"></a>Spring AOP 实现原理</h3>实现 AOP 的技术，主要分为两大类：  </li>
</ol>
<ul>
<li>动态代理：利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；  <ul>
<li>jdk 动态代理</li>
<li>CGLIB<br>CGLIB 是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意，CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的，诸如private的方法也是不可以作为切面的。</li>
</ul>
</li>
<li>静态织入：针对每个具体类分别编写代理类；针对一个接口编写一个代理类；</li>
</ul>
<h3 id="Spring-切面可以应用的通知类型有哪些？"><a href="#Spring-切面可以应用的通知类型有哪些？" class="headerlink" title="Spring 切面可以应用的通知类型有哪些？"></a>Spring 切面可以应用的通知类型有哪些？</h3><ol>
<li>before：前置通知，在一个方法执行前被调用。</li>
<li>after: 在方法执行之后调用的通知，无论方法执行是否成功。</li>
<li>after-returning: 仅当方法成功完成后执行的通知。</li>
<li>after-throwing: 在方法抛出异常退出时执行的通知。</li>
<li>around: 在方法执行之前和之后调用的通知。</li>
</ol>
<h3 id="动态代理（CGLib-与-JDK）、优缺点、性能对比、如何选择？"><a href="#动态代理（CGLib-与-JDK）、优缺点、性能对比、如何选择？" class="headerlink" title="动态代理（CGLib 与 JDK）、优缺点、性能对比、如何选择？"></a>动态代理（CGLib 与 JDK）、优缺点、性能对比、如何选择？</h3><h3 id="Spring-事务实现方式、事务的传播机制、默认的事务类别"><a href="#Spring-事务实现方式、事务的传播机制、默认的事务类别" class="headerlink" title="Spring 事务实现方式、事务的传播机制、默认的事务类别"></a>Spring 事务实现方式、事务的传播机制、默认的事务类别</h3><ul>
<li>事务的隔离级别：<ul>
<li>Read Uncommited （读未提交）</li>
<li>Read Commited   （读提交）</li>
<li>Read Repeatable （读重复）</li>
<li>Serializable    （序列化）</li>
</ul>
</li>
<li>Spring 支持 7 种事务传播行为：<ul>
<li>propagation_requierd：     如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择。</li>
<li>propagation_supports：     支持当前事务，如果没有当前事务，就以非事务方法执行。</li>
<li>propagation_mandatory：    使用当前事务，如果没有当前事务，就抛出异常。</li>
<li>propagation_required_new： 新建事务，如果当前存在事务，把当前事务挂起。</li>
<li>propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li>
<li>propagation_never：        以非事务方式执行操作，如果当前事务存在则抛出异常。</li>
<li>propagation_nested：       如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作</li>
</ul>
</li>
</ul>
<ul>
<li>Spring 默认的事务传播行为是 PROPAGATION_REQUIRED，它适合于绝大多数的情况。</li>
</ul>
<h3 id="Spring-事务底层原理"><a href="#Spring-事务底层原理" class="headerlink" title="Spring 事务底层原理"></a>Spring 事务底层原理</h3><h3 id="Spring事务失效（事务嵌套），JDK动态代理给Spring事务埋下的坑，可参考JDK动态代理给Spring事务埋下的坑！"><a href="#Spring事务失效（事务嵌套），JDK动态代理给Spring事务埋下的坑，可参考JDK动态代理给Spring事务埋下的坑！" class="headerlink" title="Spring事务失效（事务嵌套），JDK动态代理给Spring事务埋下的坑，可参考JDK动态代理给Spring事务埋下的坑！"></a>Spring事务失效（事务嵌套），JDK动态代理给Spring事务埋下的坑，可参考<a href="http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247484940&amp;idx=1&amp;sn=0a0a7198e96f57d610d3421b19573002" target="_blank" rel="noopener">JDK动态代理给Spring事务埋下的坑！</a></h3><h3 id="如何自定义注解实现功能"><a href="#如何自定义注解实现功能" class="headerlink" title="如何自定义注解实现功能"></a>如何自定义注解实现功能</h3><h3 id="Spring-MVC-工作原理-amp-执行流程？"><a href="#Spring-MVC-工作原理-amp-执行流程？" class="headerlink" title="Spring MVC 工作原理 &amp; 执行流程？"></a>Spring MVC 工作原理 &amp; 执行流程？</h3><ul>
<li>工作原理<ol>
<li>SpringMvc 把请求交给 DispactherServlet</li>
<li>DispactherServlet 查询一个或者多个 HanderMapping</li>
<li>DispactherServlet 请求 Controller</li>
<li>Controller 进行业务逻辑处理</li>
<li>找到制定的视图对象</li>
<li>视图负责渲染返回给客户端</li>
</ol>
</li>
<li>执行流程  <ol>
<li>根据配置文件创建 Spring 的容器</li>
<li>发送 http 请求到核心控制器</li>
<li>容器通过映射去寻找业务控制器</li>
<li>使用适配器找到相应的业务类，在业务类进行封装</li>
<li>数据放到 Model中 用 Map 传递数据进行页面展示</li>
</ol>
</li>
</ul>
<h3 id="Spring-MVC-启动流程"><a href="#Spring-MVC-启动流程" class="headerlink" title="Spring MVC 启动流程"></a>Spring MVC 启动流程</h3><h3 id="Spring-的单例实现原理"><a href="#Spring-的单例实现原理" class="headerlink" title="Spring 的单例实现原理"></a>Spring 的单例实现原理</h3><h3 id="Spring-框架中用到了哪些设计模式"><a href="#Spring-框架中用到了哪些设计模式" class="headerlink" title="Spring 框架中用到了哪些设计模式"></a>Spring 框架中用到了哪些设计模式</h3><h3 id="Spring-其他产品（Srping-Boot、Spring-Cloud、Spring-Secuirity、Spring-Data、Spring-AMQP-等）"><a href="#Spring-其他产品（Srping-Boot、Spring-Cloud、Spring-Secuirity、Spring-Data、Spring-AMQP-等）" class="headerlink" title="Spring 其他产品（Srping Boot、Spring Cloud、Spring Secuirity、Spring Data、Spring AMQP 等）"></a>Spring 其他产品（Srping Boot、Spring Cloud、Spring Secuirity、Spring Data、Spring AMQP 等）</h3><h3 id="有没有用到-Spring-Boot，Spring-Boot-的认识、原理"><a href="#有没有用到-Spring-Boot，Spring-Boot-的认识、原理" class="headerlink" title="有没有用到 Spring Boot，Spring Boot 的认识、原理"></a>有没有用到 Spring Boot，Spring Boot 的认识、原理</h3><h3 id="MyBatis的原理"><a href="#MyBatis的原理" class="headerlink" title="MyBatis的原理"></a>MyBatis的原理</h3><h3 id="可参考为什么会有Spring"><a href="#可参考为什么会有Spring" class="headerlink" title="可参考为什么会有Spring"></a>可参考<a href="http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247484822&amp;idx=1&amp;sn=6fbee2a12b31b6102a18d3725671d41b" target="_blank" rel="noopener">为什么会有Spring</a></h3><h3 id="可参考为什么会有Spring-AOP"><a href="#可参考为什么会有Spring-AOP" class="headerlink" title="可参考为什么会有Spring AOP"></a>可参考<a href="http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247484827&amp;idx=1&amp;sn=b9d82f3fced6a875f8dfc22e5849b28e" target="_blank" rel="noopener">为什么会有Spring AOP</a></h3><h3 id="可参考Spring历史版本变迁和如今的生态帝国"><a href="#可参考Spring历史版本变迁和如今的生态帝国" class="headerlink" title="可参考Spring历史版本变迁和如今的生态帝国"></a>可参考<a href="http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247484835&amp;idx=1&amp;sn=0210514d6eb53ad623874344f3ce720a" target="_blank" rel="noopener">Spring历史版本变迁和如今的生态帝国</a></h3><h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h2><h3 id="为什么选择-Netty"><a href="#为什么选择-Netty" class="headerlink" title="为什么选择 Netty"></a>为什么选择 Netty</h3><h3 id="说说业务中，Netty-的使用场景"><a href="#说说业务中，Netty-的使用场景" class="headerlink" title="说说业务中，Netty 的使用场景"></a>说说业务中，Netty 的使用场景</h3><h3 id="原生的-NIO-在-JDK-1-7-版本存在-epoll-bug"><a href="#原生的-NIO-在-JDK-1-7-版本存在-epoll-bug" class="headerlink" title="原生的 NIO 在 JDK 1.7 版本存在 epoll bug"></a>原生的 NIO 在 JDK 1.7 版本存在 epoll bug</h3><h3 id="什么是TCP-粘包-拆包"><a href="#什么是TCP-粘包-拆包" class="headerlink" title="什么是TCP 粘包/拆包"></a>什么是TCP 粘包/拆包</h3><h3 id="TCP粘包-拆包的解决办法"><a href="#TCP粘包-拆包的解决办法" class="headerlink" title="TCP粘包/拆包的解决办法"></a>TCP粘包/拆包的解决办法</h3><h3 id="Netty-线程模型"><a href="#Netty-线程模型" class="headerlink" title="Netty 线程模型"></a>Netty 线程模型</h3><h3 id="说说-Netty-的零拷贝"><a href="#说说-Netty-的零拷贝" class="headerlink" title="说说 Netty 的零拷贝"></a>说说 Netty 的零拷贝</h3><h3 id="Netty-内部执行流程"><a href="#Netty-内部执行流程" class="headerlink" title="Netty 内部执行流程"></a>Netty 内部执行流程</h3><h3 id="Netty-重连实现"><a href="#Netty-重连实现" class="headerlink" title="Netty 重连实现"></a>Netty 重连实现</h3><h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><h3 id="Tomcat-的基础架构（Server、Service、Connector、Container）"><a href="#Tomcat-的基础架构（Server、Service、Connector、Container）" class="headerlink" title="Tomcat 的基础架构（Server、Service、Connector、Container）"></a>Tomcat 的基础架构（Server、Service、Connector、Container）</h3><h3 id="Tomcat-如何加载-Servlet-的"><a href="#Tomcat-如何加载-Servlet-的" class="headerlink" title="Tomcat 如何加载 Servlet 的"></a>Tomcat 如何加载 Servlet 的</h3><h3 id="Pipeline-Valve-机制"><a href="#Pipeline-Valve-机制" class="headerlink" title="Pipeline-Valve 机制"></a>Pipeline-Valve 机制</h3><h3 id="可参考：四张图带你了解Tomcat系统架构！"><a href="#可参考：四张图带你了解Tomcat系统架构！" class="headerlink" title="可参考：四张图带你了解Tomcat系统架构！"></a>可参考：<a href="http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247484905&amp;idx=1&amp;sn=6c8acd89476fadbc4cb9ccfda9c9c2e4" target="_blank" rel="noopener">四张图带你了解Tomcat系统架构！</a></h3><h1 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h1><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><h3 id="请解释什么是C10K问题或者知道什么是C10K问题吗？"><a href="#请解释什么是C10K问题或者知道什么是C10K问题吗？" class="headerlink" title="请解释什么是C10K问题或者知道什么是C10K问题吗？"></a>请解释什么是C10K问题或者知道什么是C10K问题吗？</h3><h3 id="Nginx简介，可参考Nginx简介"><a href="#Nginx简介，可参考Nginx简介" class="headerlink" title="Nginx简介，可参考Nginx简介"></a>Nginx简介，可参考<a href="http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247483994&amp;idx=1&amp;sn=b6591f62c7ea6b4adc5a5bf1bf4eac40" target="_blank" rel="noopener">Nginx简介</a></h3><h3 id="正向代理和反向代理"><a href="#正向代理和反向代理" class="headerlink" title="正向代理和反向代理."></a>正向代理和反向代理.</h3><h3 id="Nginx几种常见的负载均衡策略"><a href="#Nginx几种常见的负载均衡策略" class="headerlink" title="Nginx几种常见的负载均衡策略"></a>Nginx几种常见的负载均衡策略</h3><h3 id="Nginx服务器上的Master和Worker进程分别是什么"><a href="#Nginx服务器上的Master和Worker进程分别是什么" class="headerlink" title="Nginx服务器上的Master和Worker进程分别是什么"></a>Nginx服务器上的Master和Worker进程分别是什么</h3><h3 id="使用“反向代理服务器”的优点是什么"><a href="#使用“反向代理服务器”的优点是什么" class="headerlink" title="使用“反向代理服务器”的优点是什么?"></a>使用“反向代理服务器”的优点是什么?</h3><h2 id="分布式其他"><a href="#分布式其他" class="headerlink" title="分布式其他"></a>分布式其他</h2><h3 id="什么是-CAP-定理？"><a href="#什么是-CAP-定理？" class="headerlink" title="什么是 CAP 定理？"></a>什么是 CAP 定理？</h3><p>  CAP 定理告诉我们，一个分布式系统不可能同时满足一致性（C：Consistency），可用性（A：Availability）和分区容错性（P：Partition tolerance）这三个基本需求，最多只能同时满足其中的两项。</p>
<ul>
<li><strong>一致性</strong>（Consistency）：指数据在多个副本之间是否能够保持一致的特性。</li>
<li><strong>可用性</strong>（Availability）：指系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。</li>
<li><strong>分区容错性</strong>（Partition tolerance）：分区容错性约束了一个分布式系统需要具有瑞安特性：分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。</li>
</ul>
<h3 id="什么是-BASE-理论？"><a href="#什么是-BASE-理论？" class="headerlink" title="什么是 BASE 理论？"></a>什么是 BASE 理论？</h3><ul>
<li>BASE 是 Basically Available（基本可用）、Soft state（软状态）和 Eventually consistent（最终一致性）三个短语的简写。</li>
<li>BASE 是对 CAP 中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结。</li>
<li>BASE 核心思想是即使无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。</li>
<li><strong>基本可用</strong>：指分布式系统在出现不可预知故障的时候，允许损失部分可用性（但绝不等价于系统不可用）。</li>
<li><strong>弱状态</strong>：也称软状态，指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的副本之间进行数据同步的过程存在延时。</li>
<li><strong>最终一致性</strong>：强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一直的状态。其本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</li>
</ul>
<h3 id="谈谈业务中使用分布式的场景"><a href="#谈谈业务中使用分布式的场景" class="headerlink" title="谈谈业务中使用分布式的场景"></a>谈谈业务中使用分布式的场景</h3><h3 id="Session-分布式方案"><a href="#Session-分布式方案" class="headerlink" title="Session 分布式方案"></a>Session 分布式方案</h3><h3 id="Session-分布式处理"><a href="#Session-分布式处理" class="headerlink" title="Session 分布式处理"></a>Session 分布式处理</h3><h3 id="分布式锁的应用场景、分布式锁的产生原因、基本概念"><a href="#分布式锁的应用场景、分布式锁的产生原因、基本概念" class="headerlink" title="分布式锁的应用场景、分布式锁的产生原因、基本概念"></a>分布式锁的应用场景、分布式锁的产生原因、基本概念</h3><h3 id="分布是锁的常见解决方案"><a href="#分布是锁的常见解决方案" class="headerlink" title="分布是锁的常见解决方案"></a>分布是锁的常见解决方案</h3><h3 id="分布式事务的常见解决方案"><a href="#分布式事务的常见解决方案" class="headerlink" title="分布式事务的常见解决方案"></a>分布式事务的常见解决方案</h3><h3 id="集群与负载均衡的算法与实现"><a href="#集群与负载均衡的算法与实现" class="headerlink" title="集群与负载均衡的算法与实现"></a>集群与负载均衡的算法与实现</h3><h3 id="怎么提升系统的-QPS-和吞吐量"><a href="#怎么提升系统的-QPS-和吞吐量" class="headerlink" title="怎么提升系统的 QPS 和吞吐量"></a>怎么提升系统的 QPS 和吞吐量</h3><h3 id="如何保证消息的一致性"><a href="#如何保证消息的一致性" class="headerlink" title="如何保证消息的一致性"></a>如何保证消息的一致性</h3><h3 id="CDN-实现原理"><a href="#CDN-实现原理" class="headerlink" title="CDN 实现原理"></a>CDN 实现原理</h3><h3 id="说说分库与分表设计，可参考数据库分库分表策略的具体实现方案"><a href="#说说分库与分表设计，可参考数据库分库分表策略的具体实现方案" class="headerlink" title="说说分库与分表设计，可参考数据库分库分表策略的具体实现方案"></a>说说分库与分表设计，可参考<a href="http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247483931&amp;idx=1&amp;sn=6eda41aa81c1243422a603205d2fad22" target="_blank" rel="noopener">数据库分库分表策略的具体实现方案</a></h3><h3 id="分库与分表带来的分布式困境与应对之策"><a href="#分库与分表带来的分布式困境与应对之策" class="headerlink" title="分库与分表带来的分布式困境与应对之策"></a>分库与分表带来的分布式困境与应对之策</h3><h2 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h2><h3 id="什么是-Dubbo-？"><a href="#什么是-Dubbo-？" class="headerlink" title="什么是 Dubbo ？"></a>什么是 Dubbo ？</h3><p>  Dubbo 是一个分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。</p>
<h3 id="什么是-RPC、如何实现-RPC、RPC-的实现原理，"><a href="#什么是-RPC、如何实现-RPC、RPC-的实现原理，" class="headerlink" title="什么是 RPC、如何实现 RPC、RPC 的实现原理，"></a>什么是 RPC、如何实现 RPC、RPC 的实现原理，</h3><h3 id="Dubbo-中的-SPI-是什么概念"><a href="#Dubbo-中的-SPI-是什么概念" class="headerlink" title="Dubbo 中的 SPI 是什么概念"></a>Dubbo 中的 SPI 是什么概念</h3><p>  SPI即Service Provider Interface，服务提供接口.</p>
<h3 id="Dubbo-的基本原理、执行流程"><a href="#Dubbo-的基本原理、执行流程" class="headerlink" title="Dubbo 的基本原理、执行流程"></a>Dubbo 的基本原理、执行流程</h3><ul>
<li>基本原理：<ol>
<li>client 一个线程调用远程接口，生成一个唯一的ID（比如一段随机字符串，UUID等），Dubbo 是使用 AtomicLong 从 0 开始累计数字的。</li>
<li>将打包的方法调用信息（如调用的接口名称，方法名称，参数值列表等），和处理结果的回调对象 callback，全部封装在一起，组成一个对象object。</li>
<li>向专门存放调用信息的全局 ConcurrentHashMap 里面 put(ID, object)。</li>
<li>将 ID 和打包的方法调用信息封装成一对象 connRequest，使用 IoSession.write(connRequest) 异步发送出去。</li>
<li>当前线程再使用 callback 的 get() 方法试图获取远程返回的结果，在 get() 内部，则使用 synchronized 获取回调对象 callback 的锁，再先检测是否已经获取到结果，如果没有，然后调用 callback 的 wait() 方法，释放 callback 上的锁，让当前线程处于等待状态。</li>
<li>服务端接收到请求并处理后，将结果（此结果中包含了前面的 ID，即回传）发送给客户端，客户端 socket 连接上专门监听消息的线程收到消息，分析结果，取到 ID，再从前面的 ConcurrentHashMap 里面 get(ID)，从而找到 callback，将方法调用结果设置到 callback 对象里。</li>
<li>监听线程接着使用 synchronized 获取回调对象 callback 的锁（因为前面调用过wait()，那个线程已释放 callback 的锁了），再 notifyAll()，唤醒前面处于等待状态的线程继续执行（callback的get()方法继续执行就能拿到调用结果了），至此，整个过程结束。</li>
</ol>
</li>
</ul>
<h3 id="Dubbo-适用场景：适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况"><a href="#Dubbo-适用场景：适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况" class="headerlink" title="Dubbo 适用场景：适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况"></a>Dubbo 适用场景：适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况</h3><h3 id="可参考：-3"><a href="#可参考：-3" class="headerlink" title="可参考："></a>可参考：</h3><ol>
<li><a href="https://my.oschina.net/u/1378920/blog/693374" target="_blank" rel="noopener">分布式框架dubbo原理解析</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247483931&amp;idx=1&amp;sn=6eda41aa81c1243422a603205d2fad22" target="_blank" rel="noopener">Dubbo入门</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247483900&amp;idx=1&amp;sn=c5ca198a66a701f81c2ab118fe7a734a" target="_blank" rel="noopener">基于HTTP的RPC实现</a></li>
</ol>
<h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><h3 id="Zookeeper-典型应用场景"><a href="#Zookeeper-典型应用场景" class="headerlink" title="Zookeeper 典型应用场景"></a>Zookeeper 典型应用场景</h3><ul>
<li><strong>数据发布/订阅</strong> 即所谓的配置中心，是指发布者将数据发布到 Zookeeper 的一个或一系列结点上，供订阅者进行数据订阅，进而达到动态获取数据的目的，实现配置信息的集中式管理和数据的动态更新。<br>Zookeeper采用的是推拉相结合的方式：客户端向服务端注册自己需要关注的节点，一旦该节点的数据发生变更，那么服务端就会想相应的客户端发送 Watcher 时间通知，客户端接收到这个消息通知之后，需要主动到服务端获取最新的数据。</li>
<li><strong>负载均衡</strong></li>
<li><strong>命名服务</strong></li>
<li><strong>分布式协调/通知</strong>：对于一个在多台机器上部署运行的应用而言，通常需要一个协调者来控制整个系统的运行流程，如分布式事务的处理、机器间的互相协调等。<br>通常的做法是不同的客户端都对 Zookeeper 上同一个数据节点进行 Watcher 注册，监听数据节点的变化（包括数据节点本身及其子节点），如果数据节点发生变化，那么所有订阅的客户端都能够接收到相应的 Watcher 通知，并作出相应的处理。</li>
<li><strong>集群管理</strong>：包括集群监控与集群控制两大块<br>集群机器存活性监控：监控系统在 /clusterServers 节点上注册一个 Watcher 监听，那么但凡进行动态添加机器的操作，就会在 /clusterServers 节点下创建一个临时节点：/clusterServers/[Hostname]。这样一来，监控系统就能够实时检测到机器的变动情况。</li>
<li><strong>Master选举</strong><br>利用 ZooKeeper 的强一致性，能够很好的保证在分布式高并发情况下节点的创建一定能够保证全局唯一性，即 ZooKeeper 将会保证客户端无法重复创建一个已经存在的数据节点。也就是说，如果同时有多个客户端请求创建同一个节点，那么最终一定只有一个客户端请求能够创建成功。利用这个特性，就能很容易地在分布式环境中进行 Master 选举了。</li>
<li><strong>分布式锁</strong><ul>
<li>排他锁：<ol>
<li>获取锁：所有客户端都会试图通过调用 create() 接口，在 /exclusive_lock 节点下创建临时子节点 /exclusive_lock/lock。ZooKeeper会保证在所有的客户端中，最终只有一个客户端能够创建成功，那么就可以认为该客户端获取了锁。同时，所有没有获取到锁的客户端就需要到 /exclusive_lock 节点上注册一个子节点变更的 Watcher 监听，以便实时监听到 lock 节点的变更情况。</li>
<li>释放锁：<ul>
<li>当前获取锁的客户端机器发生宕机，那么 ZooKeeper 上的这个临时节点（/exclusive_lock/lock）就会被删除</li>
<li>正常执行完业务逻辑后，客户端就会主动将自己创建的临时节点（/exclusive_lock/lock）删除。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><strong>分布式队列</strong></li>
</ul>
<h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><h3 id="前后端分离是如何做的？"><a href="#前后端分离是如何做的？" class="headerlink" title="前后端分离是如何做的？"></a>前后端分离是如何做的？</h3><h3 id="微服务哪些框架"><a href="#微服务哪些框架" class="headerlink" title="微服务哪些框架"></a>微服务哪些框架</h3><h3 id="Spring-Could的常见组件有哪些？可参考Spring-Cloud概述"><a href="#Spring-Could的常见组件有哪些？可参考Spring-Cloud概述" class="headerlink" title="Spring Could的常见组件有哪些？可参考Spring Cloud概述"></a>Spring Could的常见组件有哪些？可参考<a href="http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247484125&amp;idx=1&amp;sn=ddba9fba6ae900f5ef71a68f70afebe5" target="_blank" rel="noopener">Spring Cloud概述</a></h3><h3 id="领域驱动有了解吗？什么是领域驱动模型？充血模型、贫血模型"><a href="#领域驱动有了解吗？什么是领域驱动模型？充血模型、贫血模型" class="headerlink" title="领域驱动有了解吗？什么是领域驱动模型？充血模型、贫血模型"></a>领域驱动有了解吗？什么是领域驱动模型？充血模型、贫血模型</h3><h3 id="JWT有了解吗，什么是JWT，可参考前后端分离利器之JWT"><a href="#JWT有了解吗，什么是JWT，可参考前后端分离利器之JWT" class="headerlink" title="JWT有了解吗，什么是JWT，可参考前后端分离利器之JWT"></a>JWT有了解吗，什么是JWT，可参考<a href="http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247485183&amp;idx=1&amp;sn=05dac824dbb534710dd99d6c895fbaf5" target="_blank" rel="noopener">前后端分离利器之JWT</a></h3><h3 id="你怎么理解-RESTful"><a href="#你怎么理解-RESTful" class="headerlink" title="你怎么理解 RESTful"></a>你怎么理解 RESTful</h3><h3 id="说说如何设计一个良好的-API"><a href="#说说如何设计一个良好的-API" class="headerlink" title="说说如何设计一个良好的 API"></a>说说如何设计一个良好的 API</h3><h3 id="如何理解-RESTful-API-的幂等性"><a href="#如何理解-RESTful-API-的幂等性" class="headerlink" title="如何理解 RESTful API 的幂等性"></a>如何理解 RESTful API 的幂等性</h3><h3 id="如何保证接口的幂等性"><a href="#如何保证接口的幂等性" class="headerlink" title="如何保证接口的幂等性"></a>如何保证接口的幂等性</h3><h3 id="说说-CAP-定理、BASE-理论"><a href="#说说-CAP-定理、BASE-理论" class="headerlink" title="说说 CAP 定理、BASE 理论"></a>说说 CAP 定理、BASE 理论</h3><h3 id="怎么考虑数据一致性问题"><a href="#怎么考虑数据一致性问题" class="headerlink" title="怎么考虑数据一致性问题"></a>怎么考虑数据一致性问题</h3><h3 id="说说最终一致性的实现方案"><a href="#说说最终一致性的实现方案" class="headerlink" title="说说最终一致性的实现方案"></a>说说最终一致性的实现方案</h3><h3 id="微服务的优缺点，可参考微服务批判"><a href="#微服务的优缺点，可参考微服务批判" class="headerlink" title="微服务的优缺点，可参考微服务批判"></a>微服务的优缺点，可参考<a href="http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247485005&amp;idx=1&amp;sn=78a1d286c6a15a81ea5dcf6634a70b54" target="_blank" rel="noopener">微服务批判</a></h3><h3 id="微服务与-SOA-的区别"><a href="#微服务与-SOA-的区别" class="headerlink" title="微服务与 SOA 的区别"></a>微服务与 SOA 的区别</h3><h3 id="如何拆分服务、水平分割、垂直分割"><a href="#如何拆分服务、水平分割、垂直分割" class="headerlink" title="如何拆分服务、水平分割、垂直分割"></a>如何拆分服务、水平分割、垂直分割</h3><h3 id="如何应对微服务的链式调用异常"><a href="#如何应对微服务的链式调用异常" class="headerlink" title="如何应对微服务的链式调用异常"></a>如何应对微服务的链式调用异常</h3><h3 id="如何快速追踪与定位问题"><a href="#如何快速追踪与定位问题" class="headerlink" title="如何快速追踪与定位问题"></a>如何快速追踪与定位问题</h3><h3 id="如何保证微服务的安全、认证"><a href="#如何保证微服务的安全、认证" class="headerlink" title="如何保证微服务的安全、认证"></a>如何保证微服务的安全、认证</h3><h2 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h2><h3 id="如何防范常见的Web攻击、如何方式SQL注入"><a href="#如何防范常见的Web攻击、如何方式SQL注入" class="headerlink" title="如何防范常见的Web攻击、如何方式SQL注入"></a>如何防范常见的Web攻击、如何方式SQL注入</h3><h3 id="服务端通信安全攻防"><a href="#服务端通信安全攻防" class="headerlink" title="服务端通信安全攻防"></a>服务端通信安全攻防</h3><h3 id="HTTPS原理剖析、降级攻击、HTTP与HTTPS的对比"><a href="#HTTPS原理剖析、降级攻击、HTTP与HTTPS的对比" class="headerlink" title="HTTPS原理剖析、降级攻击、HTTP与HTTPS的对比"></a>HTTPS原理剖析、降级攻击、HTTP与HTTPS的对比</h3><h3 id="OAuth"><a href="#OAuth" class="headerlink" title="OAuth"></a>OAuth</h3><ul>
<li>概念：OAuth 是一个关于授权的开放网络标准。</li>
</ul>
<ul>
<li>作用：<ul>
<li>不需要将用户名和密码提供给第三方应用而是通过令牌让第三方应用访问资源</li>
<li>每一个令牌授权一个特定的应用在特定的时段内访问特定的资源</li>
</ul>
</li>
<li>授权流程：<ol>
<li>用户打开客户端以后，客户端要求用户给予授权</li>
<li>用户同意授权</li>
<li>客户端使用上一步获得的授权，向认证服务器申请令牌</li>
<li>认证服务器对客户端进行认证以后，确认无误并且发放令牌</li>
<li>客户端使用令牌向资源服务器申请获取资源</li>
<li>资源服务器确认令牌无误同意向客户端开放资源      </li>
</ol>
</li>
</ul>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="性能指标有哪些"><a href="#性能指标有哪些" class="headerlink" title="性能指标有哪些"></a>性能指标有哪些</h3><h3 id="如何发现性能瓶颈"><a href="#如何发现性能瓶颈" class="headerlink" title="如何发现性能瓶颈"></a>如何发现性能瓶颈</h3><h3 id="性能调优的常见手段"><a href="#性能调优的常见手段" class="headerlink" title="性能调优的常见手段"></a>性能调优的常见手段</h3><h3 id="说说你在项目中如何进行性能调优"><a href="#说说你在项目中如何进行性能调优" class="headerlink" title="说说你在项目中如何进行性能调优"></a>说说你在项目中如何进行性能调优</h3><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="设计能力"><a href="#设计能力" class="headerlink" title="设计能力"></a>设计能力</h2><h3 id="说说你在项目中使用过的-UML-图"><a href="#说说你在项目中使用过的-UML-图" class="headerlink" title="说说你在项目中使用过的 UML 图"></a>说说你在项目中使用过的 UML 图</h3><h3 id="你如何考虑组件化、服务化、系统拆分"><a href="#你如何考虑组件化、服务化、系统拆分" class="headerlink" title="你如何考虑组件化、服务化、系统拆分"></a>你如何考虑组件化、服务化、系统拆分</h3><h3 id="秒杀场景如何设计"><a href="#秒杀场景如何设计" class="headerlink" title="秒杀场景如何设计"></a>秒杀场景如何设计</h3><h3 id="有没有处理过线上问题？出现内存泄露，CPU-利用率标高，应用无响应时如何处理的。"><a href="#有没有处理过线上问题？出现内存泄露，CPU-利用率标高，应用无响应时如何处理的。" class="headerlink" title="有没有处理过线上问题？出现内存泄露，CPU 利用率标高，应用无响应时如何处理的。"></a>有没有处理过线上问题？出现内存泄露，CPU 利用率标高，应用无响应时如何处理的。</h3><h3 id="开发中有没有遇到什么技术问题？如何解决的"><a href="#开发中有没有遇到什么技术问题？如何解决的" class="headerlink" title="开发中有没有遇到什么技术问题？如何解决的"></a>开发中有没有遇到什么技术问题？如何解决的</h3><h3 id="如果有几十亿的白名单，每天白天需要高并发查询，晚上需要更新一次，如何设计这个功能。"><a href="#如果有几十亿的白名单，每天白天需要高并发查询，晚上需要更新一次，如何设计这个功能。" class="headerlink" title="如果有几十亿的白名单，每天白天需要高并发查询，晚上需要更新一次，如何设计这个功能。"></a>如果有几十亿的白名单，每天白天需要高并发查询，晚上需要更新一次，如何设计这个功能。</h3><h3 id="新浪微博是如何实现把微博推给订阅者"><a href="#新浪微博是如何实现把微博推给订阅者" class="headerlink" title="新浪微博是如何实现把微博推给订阅者"></a>新浪微博是如何实现把微博推给订阅者</h3><h3 id="Google-是如何在一秒内把搜索结果返回给用户的。"><a href="#Google-是如何在一秒内把搜索结果返回给用户的。" class="headerlink" title="Google 是如何在一秒内把搜索结果返回给用户的。"></a>Google 是如何在一秒内把搜索结果返回给用户的。</h3><h3 id="12306-网站的订票系统如何实现，如何保证不会票不被超卖。"><a href="#12306-网站的订票系统如何实现，如何保证不会票不被超卖。" class="headerlink" title="12306 网站的订票系统如何实现，如何保证不会票不被超卖。"></a>12306 网站的订票系统如何实现，如何保证不会票不被超卖。</h3><h3 id="如何实现一个秒杀系统，保证只有几位用户能买到某件商品。"><a href="#如何实现一个秒杀系统，保证只有几位用户能买到某件商品。" class="headerlink" title="如何实现一个秒杀系统，保证只有几位用户能买到某件商品。"></a>如何实现一个秒杀系统，保证只有几位用户能买到某件商品。</h3><h3 id="可参考：秒杀系统的技术挑战、应对策略以及架构设计总结一二！"><a href="#可参考：秒杀系统的技术挑战、应对策略以及架构设计总结一二！" class="headerlink" title="可参考：秒杀系统的技术挑战、应对策略以及架构设计总结一二！"></a>可参考：秒杀系统的技术挑战、应对策略以及架构设计总结一二！</h3><h3 id="可参考：大型网站应用之海量数据和高并发解决方案总结一二"><a href="#可参考：大型网站应用之海量数据和高并发解决方案总结一二" class="headerlink" title="可参考：大型网站应用之海量数据和高并发解决方案总结一二"></a>可参考：<a href="https://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247483917&amp;idx=1&amp;sn=db1b0a2093d3c0d1bb6e32263abfe137" target="_blank" rel="noopener">大型网站应用之海量数据和高并发解决方案总结一二</a></h3><h2 id="业务工程"><a href="#业务工程" class="headerlink" title="业务工程"></a>业务工程</h2><h3 id="说说你的开发流程、如何进行自动化部署的"><a href="#说说你的开发流程、如何进行自动化部署的" class="headerlink" title="说说你的开发流程、如何进行自动化部署的"></a>说说你的开发流程、如何进行自动化部署的</h3><h3 id="你和团队是如何沟通的"><a href="#你和团队是如何沟通的" class="headerlink" title="你和团队是如何沟通的"></a>你和团队是如何沟通的</h3><h3 id="你如何进行代码评审"><a href="#你如何进行代码评审" class="headerlink" title="你如何进行代码评审"></a>你如何进行代码评审</h3><h3 id="说说你对技术与业务的理解"><a href="#说说你对技术与业务的理解" class="headerlink" title="说说你对技术与业务的理解"></a>说说你对技术与业务的理解</h3><h3 id="说说你在项目中遇到感觉最难Bug，是如何解决的"><a href="#说说你在项目中遇到感觉最难Bug，是如何解决的" class="headerlink" title="说说你在项目中遇到感觉最难Bug，是如何解决的"></a>说说你在项目中遇到感觉最难Bug，是如何解决的</h3><h3 id="介绍一下工作中的一个你认为最有价值的项目，以及在这个过程中的角色、解决的问题、你觉得你们项目还有哪些不足的地方"><a href="#介绍一下工作中的一个你认为最有价值的项目，以及在这个过程中的角色、解决的问题、你觉得你们项目还有哪些不足的地方" class="headerlink" title="介绍一下工作中的一个你认为最有价值的项目，以及在这个过程中的角色、解决的问题、你觉得你们项目还有哪些不足的地方"></a>介绍一下工作中的一个你认为最有价值的项目，以及在这个过程中的角色、解决的问题、你觉得你们项目还有哪些不足的地方</h3><h2 id="软实力"><a href="#软实力" class="headerlink" title="软实力"></a>软实力</h2><h3 id="说说你的优缺点、亮点"><a href="#说说你的优缺点、亮点" class="headerlink" title="说说你的优缺点、亮点"></a>说说你的优缺点、亮点</h3><h3 id="说说你最近在看什么书、什么博客、在研究什么新技术、再看那些开源项目的源代码"><a href="#说说你最近在看什么书、什么博客、在研究什么新技术、再看那些开源项目的源代码" class="headerlink" title="说说你最近在看什么书、什么博客、在研究什么新技术、再看那些开源项目的源代码"></a>说说你最近在看什么书、什么博客、在研究什么新技术、再看那些开源项目的源代码</h3><h3 id="说说你觉得最有意义的技术书籍"><a href="#说说你觉得最有意义的技术书籍" class="headerlink" title="说说你觉得最有意义的技术书籍"></a>说说你觉得最有意义的技术书籍</h3><h3 id="工作之余做什么事情、平时是如何学习的，怎样提升自己的能力"><a href="#工作之余做什么事情、平时是如何学习的，怎样提升自己的能力" class="headerlink" title="工作之余做什么事情、平时是如何学习的，怎样提升自己的能力"></a>工作之余做什么事情、平时是如何学习的，怎样提升自己的能力</h3><h3 id="说说个人发展方向方面的思考"><a href="#说说个人发展方向方面的思考" class="headerlink" title="说说个人发展方向方面的思考"></a>说说个人发展方向方面的思考</h3><h3 id="说说你认为的服务端开发工程师应该具备哪些能力"><a href="#说说你认为的服务端开发工程师应该具备哪些能力" class="headerlink" title="说说你认为的服务端开发工程师应该具备哪些能力"></a>说说你认为的服务端开发工程师应该具备哪些能力</h3><h3 id="说说你认为的架构师是什么样的，架构师主要做什么"><a href="#说说你认为的架构师是什么样的，架构师主要做什么" class="headerlink" title="说说你认为的架构师是什么样的，架构师主要做什么"></a>说说你认为的架构师是什么样的，架构师主要做什么</h3><h3 id="如何看待加班的问题"><a href="#如何看待加班的问题" class="headerlink" title="如何看待加班的问题"></a>如何看待加班的问题</h3><h2 id="面试技巧"><a href="#面试技巧" class="headerlink" title="面试技巧"></a>面试技巧</h2><h3 id="可参考：-4"><a href="#可参考：-4" class="headerlink" title="可参考："></a>可参考：</h3><ol>
<li><a href="http://gitbook.cn/books/5a6985f12a144149588739a5/index.html" target="_blank" rel="noopener">程序员跳槽时，如何高效地准备面试？</a></li>
<li><a href="http://gitbook.cn/books/5a73206362710202070b47ac/index.html" target="_blank" rel="noopener">才震宏：解析程序员跳槽时如何高效地准备面试</a></li>
<li><a href="http://gitbook.cn/books/5a9f529e123f227c0649d946/index.html" target="_blank" rel="noopener">程序员跳槽时，如何正确做好职业规划？</a></li>
<li><a href="http://gitbook.cn/books/5aa9fa860bb9e857450e70ad/index.html" target="_blank" rel="noopener">王鹏：解析程序员跳槽时如何正确做好职业规划</a></li>
<li><a href="http://gitbook.cn/books/5a951e93ba2cd224ba9480a7/index.html" target="_blank" rel="noopener">程序员跳槽时，如何优雅地谈薪水？</a></li>
<li><a href="http://gitbook.cn/books/5aa0bdf7f622f7137a21bf9e/index.html" target="_blank" rel="noopener">于丽洋：解析程序员跳槽时如何优雅地谈薪水</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring]]></title>
      <url>/2018/03/07/spring/</url>
      <content type="html"><![CDATA[<ol>
<li><a href="http://blog.csdn.net/luanlouis/article/details/51095702" target="_blank" rel="noopener">Spring AOP 设计原理</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> Spring </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Spring </tag>
            
            <tag> AOP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java8 Blogs]]></title>
      <url>/2018/03/07/java-io/</url>
      <content type="html"><![CDATA[<h2 id="一、相关帖子整理"><a href="#一、相关帖子整理" class="headerlink" title="一、相关帖子整理"></a>一、相关帖子整理</h2><ol>
<li><a href="http://ginobefunny.com/post/java_nio_interview_questions/" target="_blank" rel="noopener">面试小结之IO篇</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> IO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IO </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis]]></title>
      <url>/2018/03/07/redis/</url>
      <content type="html"><![CDATA[<h2 id="1-Redis-有哪些数据结构？"><a href="#1-Redis-有哪些数据结构？" class="headerlink" title="1. Redis 有哪些数据结构？"></a>1. Redis 有哪些数据结构？</h2><ul>
<li><p>String(字符串)</p>
<ul>
<li>append</li>
<li>set</li>
<li>get / mget</li>
<li>incr</li>
</ul>
</li>
<li><p>Hash(字典)</p>
<ul>
<li>hset</li>
<li>hget</li>
<li>hdel</li>
<li>hexist</li>
<li>hincrby</li>
</ul>
</li>
<li><p>List(列表)</p>
<ul>
<li>lpush / rpush</li>
<li>lpop  / rpop</li>
<li>blpop / brpop<br>-</li>
</ul>
</li>
<li><p>Set(集合)</p>
<ul>
<li>sadd</li>
<li>smove ：将 member 元素从 source 集合移动到 destination 集合。[SMOVE source destination member]</li>
<li>spop  ：移除并返回集合中的一个随机元素。</li>
<li>srem  ：移除集合 key 中的一个或多个 member 元素，不存在的 member 元素会被忽略。[SREM key member [member …]]</li>
<li>smembers：返回集合 key 中的所有成员。[SMEMBERS key]</li>
</ul>
</li>
<li><p>SortedSet(有序集合)</p>
<ul>
<li>zadd</li>
<li>zincrby</li>
<li>zrem / zremrangebyrank</li>
<li>zrange / zrangebyscore</li>
</ul>
</li>
<li><p>HyperLogLog</p>
<ul>
<li>用于基数统计</li>
<li>HyperLogLog 键内存占用仅需 12K，可计算近 2^64 个不同元素的基数。</li>
<li>算法给出的基数并不是精确的，是估算值。</li>
</ul>
</li>
<li><p>Geo</p>
</li>
<li><p>Pub/Sub(发布订阅)</p>
<ul>
<li>publish</li>
<li>subscribe</li>
<li>unsubscribe</li>
</ul>
</li>
</ul>
<h2 id="2-如何使用-Redis-实现分布式锁？"><a href="#2-如何使用-Redis-实现分布式锁？" class="headerlink" title="2. 如何使用 Redis 实现分布式锁？"></a>2. 如何使用 Redis 实现分布式锁？</h2><ul>
<li>先用 setnx 来争抢锁，抢到之后，再用 expire 给锁加一个过期时间防止锁忘记了释放。或者直接使用：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET key-with-expire-and-NX &quot;lock&quot; EX 10086 NX</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3-假如-Redis-里面有1亿个-key，其中有-10w-个-key-是以某个固定的已知的前缀开头的，如果将它们全部找出来？"><a href="#3-假如-Redis-里面有1亿个-key，其中有-10w-个-key-是以某个固定的已知的前缀开头的，如果将它们全部找出来？" class="headerlink" title="3. 假如 Redis 里面有1亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？"></a>3. 假如 Redis 里面有1亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？</h2><ul>
<li>使用 keys 指令可以扫出指定模式的 key 列表。<ul>
<li>如果这个 redis 正在给线上的业务提供服务，那使用 keys 指令会有什么问题？<br>redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</li>
</ul>
</li>
</ul>
<h2 id="4-如何使用-Redis-实现异步队列？"><a href="#4-如何使用-Redis-实现异步队列？" class="headerlink" title="4. 如何使用 Redis 实现异步队列？"></a>4. 如何使用 Redis 实现异步队列？</h2><ul>
<li>一般使用 list 结构作为队列，rpush 生产消息，lpop 消费消息。当 lpop 没有消息的时候，要适当 sleep 一会再重试。<ul>
<li>可不可以不用 sleep？<br>list 还有个指令叫 blpop，在没有消息的时候，它会阻塞住直到消息到来。</li>
<li>能不能生产一次消费多次呢？<br>使用pub/sub主题订阅者模式，可以实现1:N的消息队列。</li>
</ul>
</li>
<li>Redis 如何实现延时队列？<ul>
<li>使用 sortedset，拿时间戳作为 score，调用 zadd 来生产消息，消费者用 zrangebyscore 指令获取 N 秒之前的数据轮询进行处理。</li>
</ul>
</li>
</ul>
<h2 id="5-如果有大量的-key-需要设置同一时间过期，一般需要注意什么？"><a href="#5-如果有大量的-key-需要设置同一时间过期，一般需要注意什么？" class="headerlink" title="5. 如果有大量的 key 需要设置同一时间过期，一般需要注意什么？"></a>5. 如果有大量的 key 需要设置同一时间过期，一般需要注意什么？</h2><p>  如果大量的 key 过期时间设置的过于集中，到过期的那个时间点，redis 可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一些。</p>
<h2 id="6-Redis-如何做持久化？"><a href="#6-Redis-如何做持久化？" class="headerlink" title="6. Redis 如何做持久化？"></a>6. <a href="http://doc.redisfans.com/topic/persistence.html" target="_blank" rel="noopener">Redis 如何做持久化？</a></h2><ul>
<li>使用 BGSAVE 命令做镜像全量持久化。<ul>
<li>bgsave 的原理是什么？<br>命令执行之后立即返回 OK ，然后 Redis fork 出一个新子进程，原来的 Redis 进程(父进程)继续处理客户端请求，而子进程则负责将数据保存到磁盘，然后退出。</li>
</ul>
</li>
<li>RDB 持久化可以在指定的时间间隔内生成数据集的时间点快照</li>
<li>AOF 持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。</li>
<li>Redis 还可以同时使用 AOF 持久化和 RDB 持久化。 在这种情况下， 当 Redis 重启时， 它会优先使用 AOF 文件来还原数据集， 因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。</li>
</ul>
<h2 id="7-Pipeline有什么好处，为什么要用pipeline？"><a href="#7-Pipeline有什么好处，为什么要用pipeline？" class="headerlink" title="7. Pipeline有什么好处，为什么要用pipeline？"></a>7. Pipeline有什么好处，为什么要用pipeline？</h2><ul>
<li>可以将多次 IO 往返的时间缩减为一次，前提是 pipeline 执行的指令之间没有因果相关性。</li>
</ul>
<h2 id="8-Redis的同步机制了解么？"><a href="#8-Redis的同步机制了解么？" class="headerlink" title="8. Redis的同步机制了解么？"></a>8. <a href="http://doc.redisfans.com/topic/replication.html#id1" target="_blank" rel="noopener">Redis的同步机制了解么？</a></h2><p>  Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。</p>
<h2 id="9-Redis-集群原理？"><a href="#9-Redis-集群原理？" class="headerlink" title="9. Redis 集群原理？"></a>9. Redis 集群原理？</h2><p>  Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。<br>  Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。</p>
<h2 id="10-Redis-常见应用场景"><a href="#10-Redis-常见应用场景" class="headerlink" title="10. Redis 常见应用场景"></a>10. Redis 常见应用场景</h2><ul>
<li>全页面缓存</li>
<li>排行榜</li>
<li>Session 存储</li>
<li>队列</li>
<li>发布/订阅</li>
<li><p>分布式锁</p>
</li>
<li><p>案例</p>
<ul>
<li><a href="https://tech.imdada.cn/2017/06/30/daojia-redis/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="noopener">Redis在京东到家的订单中的使用</a></li>
</ul>
</li>
</ul>
<p>引用：<br>  <a href="https://mp.weixin.qq.com/s/507jyNbL4xCkxyW6Xk15Xg" target="_blank" rel="noopener">天下无难试之Redis面试刁难大全</a></p>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java Skills]]></title>
      <url>/2018/02/02/java-skills/</url>
      <content type="html"><![CDATA[<h1 id="专业技能"><a href="#专业技能" class="headerlink" title="专业技能"></a>专业技能</h1><ol>
<li><a href="https://github.com/tangyouhua/program-resource/blob/master/program-interview/java-baidu-200.md" target="_blank" rel="noopener">Java 面试题整理(没有答案)</a></li>
<li><a href="http://blog.csdn.net/jackfrued/article/details/44921941" target="_blank" rel="noopener">Java面试题全集（上）</a></li>
<li><a href="http://blog.csdn.net/jackfrued/article/details/44931137" target="_blank" rel="noopener">Java面试题全集（中）</a></li>
<li><a href="http://blog.csdn.net/jackfrued/article/details/44931161" target="_blank" rel="noopener">Java面试题全集（下）</a></li>
<li><a href="http://www.importnew.com/23896.html" target="_blank" rel="noopener">关于Java面试，你应该准备这些知识点</a></li>
</ol>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><ol>
<li>static, final, transient 等关键字作用</li>
<li><a href="http://www.importnew.com/27002.html" target="_blank" rel="noopener">volatile</a></li>
<li>抽象类与接口的区别</li>
</ol>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><ol>
<li><a href="https://www.jianshu.com/p/63e76826e852" target="_blank" rel="noopener">Java - 集合框架完全解析</a></li>
<li><a href="http://www.importnew.com/15980.html" target="_blank" rel="noopener">40个Java集合面试问题和答案</a>  </li>
</ol>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><ol>
<li>锁分段技术（Java8 之前版本）  </li>
<li>读操作是否要加锁，为什么。  </li>
<li>其迭代器是强一致性的还是弱一致性的。  </li>
</ol>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><h3 id="File-IO"><a href="#File-IO" class="headerlink" title="File IO"></a>File IO</h3><h3 id="Socket-IO"><a href="#Socket-IO" class="headerlink" title="Socket IO"></a>Socket IO</h3><ol>
<li>概念  <ul>
<li>搞懂阻塞/非阻塞的区别、同步/异步的区别</li>
<li>理解阻塞IO、非阻塞IO、多路复用IO、异步IO这四种IO模型</li>
<li>Socket IO 如何和这四种模型相关联</li>
</ul>
</li>
<li>NIO的原理</li>
<li>NIO属于哪种IO模型</li>
<li>NIO的三大组成</li>
<li>Netty</li>
</ol>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><ol>
<li>Java 虚拟机的内存布局</li>
<li>GC 算法及几种垃圾收集器</li>
<li>类加载机制，也就是双亲委派模型</li>
<li>Java 内存模型</li>
<li>happens-before 规则</li>
<li>volatile 关键字使用规则</li>
<li>JSR-133 volatile final 语义增强</li>
</ol>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>  <a href="http://welkinbai.coding.me/2016/08/15/mysql-intro/" target="_blank" rel="noopener">《高性能Mysql》读书笔记</a></p>
<ol>
<li>复杂SQL与优化</li>
<li>事务机制</li>
<li>Spring事务应用</li>
<li>索引原理</li>
</ol>
<h2 id="开源框架"><a href="#开源框架" class="headerlink" title="开源框架"></a>开源框架</h2><h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><ol>
<li><a href="http://blog.csdn.net/u013256816/article/details/51386182" target="_blank" rel="noopener">Spring 知识点</a></li>
<li><a href="http://ifeve.com/spring-interview-questions-and-answers/" target="_blank" rel="noopener">69道Spring面试题和答案</a>  </li>
</ol>
<h3 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h3><h3 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h3><h3 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h3><h3 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h3><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><h3 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h3><h3 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h3><h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><ol>
<li><a href="http://www.jasongj.com/tags/Kafka/" target="_blank" rel="noopener">http://www.jasongj.com/tags/Kafka/</a></li>
</ol>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ol>
<li><a href="https://github.com/kdn251/interviews/blob/master/README-zh-cn.md" target="_blank" rel="noopener">很全面的算法和数据结构知识</a></li>
<li><a href="https://www.jianshu.com/p/230e6fde9c75" target="_blank" rel="noopener">常见数据结构与算法整理总结（上）</a></li>
<li><a href="https://www.jianshu.com/p/42f81846c0fb" target="_blank" rel="noopener">常见数据结构与算法整理总结（下）</a>  </li>
</ol>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><ol>
<li>二叉查找树</li>
<li>平衡二叉查找树（AVL树）</li>
<li>红黑树</li>
</ol>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ol>
<li><a href="https://itimetraveler.github.io/2017/07/18/八大排序算法总结与java实现/" target="_blank" rel="noopener">常见排序算法</a><br>2.<br>3.</li>
</ol>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h2 id="Java-Web"><a href="#Java-Web" class="headerlink" title="Java Web"></a>Java Web</h2><ol>
<li>Servlet<ul>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-servlet/" target="_blank" rel="noopener">原理</a></li>
<li>生命周期</li>
</ul>
</li>
<li>Tomcat</li>
</ol>
<h2 id="架构能力"><a href="#架构能力" class="headerlink" title="架构能力"></a>架构能力</h2><h3 id="用过哪些中间件：Zookeeper-Kafka"><a href="#用过哪些中间件：Zookeeper-Kafka" class="headerlink" title="用过哪些中间件：Zookeeper, Kafka"></a>用过哪些中间件：Zookeeper, Kafka</h3><h3 id="Zookeeper-作用"><a href="#Zookeeper-作用" class="headerlink" title="Zookeeper 作用"></a>Zookeeper 作用</h3><h3 id="分布式事务解决"><a href="#分布式事务解决" class="headerlink" title="分布式事务解决"></a>分布式事务解决</h3><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><h3 id="对-CAP-BASE-ACID-的理解"><a href="#对-CAP-BASE-ACID-的理解" class="headerlink" title="对 CAP, BASE, ACID 的理解"></a><a href="http://blog.csdn.net/sunxinhere/article/details/7936485" target="_blank" rel="noopener">对 CAP, BASE, ACID 的理解</a></h3><h1 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h1><ol>
<li><a href="http://blog.jobbole.com/78229/" target="_blank" rel="noopener">程序员如何写出杀手级的简历</a></li>
<li><a href="http://blog.csdn.net/Bens2014/article/details/25565779" target="_blank" rel="noopener">十大面试问题解惑</a></li>
</ol>
<h2 id="项目经验"><a href="#项目经验" class="headerlink" title="项目经验"></a>项目经验</h2><h2 id="提问方式"><a href="#提问方式" class="headerlink" title="提问方式"></a>提问方式</h2><ol>
<li>连环提问  <ul>
<li>多线程模型 - &gt; 各种状态之间转换 -&gt; jdk常见的并发类 -&gt; 如何保证线程安全 -&gt; volatile 实现原理 -&gt; 线程池与队列 -&gt; 调优  </li>
<li>spring 特点 -&gt; AOP 原理 -&gt; 代理种类 -&gt; 实现细节 -&gt; CGLib 局限 -&gt; 性能如何  </li>
<li>JVM 组成 -&gt; 内存模型 -&gt; 垃圾收集算法 -&gt; 类加载 -&gt; 收集器类型 -&gt; 如何调优  </li>
<li>spring MVC 组成 - &gt; 怎么映射控制器 -&gt; 控制器单例否 -&gt; 拦截器应用  </li>
<li>使用过 MySQL -&gt; 数据库引擎区别 -&gt; 事务控制 - &gt; 隔离级别 -&gt; 加锁种类区别 -&gt; spring事务传播 -&gt; 区别  </li>
<li>分布式和集群区别 -&gt; 服务发现和负载均衡 -&gt; 中间件 -&gt; 分布式事务处理 -&gt; 缓存设计  </li>
</ul>
</li>
</ol>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><blockquote>
<p><a href="http://www.cnblogs.com/xrq730/p/5260294.html" target="_blank" rel="noopener">http://www.cnblogs.com/xrq730/p/5260294.html</a><br><a href="https://segmentfault.com/a/1190000004716061" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004716061</a><br><a href="http://blog.csdn.net/micro_hz/article/details/77992185" target="_blank" rel="noopener">http://blog.csdn.net/micro_hz/article/details/77992185</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 面试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Microservice Blogs]]></title>
      <url>/2018/02/01/microservice/</url>
      <content type="html"><![CDATA[<h3 id="多研究些架构，少谈些框架"><a href="#多研究些架构，少谈些框架" class="headerlink" title="多研究些架构，少谈些框架"></a>多研究些架构，少谈些框架</h3><ol>
<li><a href="https://github.com/JoeCao/JoeCao.github.io/issues/3" target="_blank" rel="noopener">论微服务架构的核心概念</a></li>
<li><a href="https://github.com/JoeCao/JoeCao.github.io/issues/4" target="_blank" rel="noopener">微服务和充血模型</a></li>
<li><a href="https://github.com/JoeCao/JoeCao.github.io/issues/5" target="_blank" rel="noopener">微服务和事件驱动</a></li>
<li><a href="https://github.com/JoeCao/JoeCao.github.io/issues/6" target="_blank" rel="noopener">架构师是技术的使用者而不是信徒</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> 微服务 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 微服务 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[设计模式 Blogs]]></title>
      <url>/2018/02/01/design-patterns/</url>
      <content type="html"><![CDATA[<h3 id="常用开源框架中设计模式使用分析"><a href="#常用开源框架中设计模式使用分析" class="headerlink" title="常用开源框架中设计模式使用分析"></a>常用开源框架中设计模式使用分析</h3><ol>
<li><a href="http://mp.weixin.qq.com/s/gbQoAS_lhJX3n6QNb6fYrA" target="_blank" rel="noopener">单例设计模式</a></li>
<li><a href="http://blog.csdn.net/likailonghaha/article/details/53190070" target="_blank" rel="noopener">jdk中的23种设计模式体现</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数据库 Blogs]]></title>
      <url>/2018/02/01/database/</url>
      <content type="html"></content>
      
        <categories>
            
            <category> 数据库 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Database </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Computer Network Blogs]]></title>
      <url>/2018/02/01/computer-network/</url>
      <content type="html"><![CDATA[<ol>
<li><a href="https://mp.weixin.qq.com/s/f4xxwS1ISsNEt9gzLGr4dA" target="_blank" rel="noopener">就是要你懂TCP – 握手和挥手</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> 计算机网络 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Network </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java 并发编程 Blogs]]></title>
      <url>/2018/02/01/concurrency-programming/</url>
      <content type="html"><![CDATA[<ol>
<li><a href="https://mp.weixin.qq.com/s/3ZGamy4zX_NhZisOiZD91w" target="_blank" rel="noopener">高并发编程必备基础(上)</a></li>
<li><a href="http://mp.weixin.qq.com/s/wqRjLo3HhKMDwAQm_rm_DA" target="_blank" rel="noopener">高并发编程必备基础(下)</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
            <category> 并发编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Concurrency </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java8 Blogs]]></title>
      <url>/2018/01/31/java8/</url>
      <content type="html"><![CDATA[<ol>
<li><a href="https://mp.weixin.qq.com/s/CWNIRk9xGu2XSbrWELTKNg" target="_blank" rel="noopener">Java 8的新特性—终极版</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java8 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JVM Blogs]]></title>
      <url>/2018/01/31/jvm-blogs/</url>
      <content type="html"><![CDATA[<h2 id="一、相关帖子整理"><a href="#一、相关帖子整理" class="headerlink" title="一、相关帖子整理"></a>一、相关帖子整理</h2><ol>
<li><a href="http://ifeve.com/under-the-hood-runtime-data-areas-javas-memory-model/" target="_blank" rel="noopener">JAVA的内存模型及结构</a></li>
<li><a href="http://www.cnblogs.com/ityouknow/p/5610232.html" target="_blank" rel="noopener">JVM（2）：JVM内存结构</a></li>
<li><a href="http://www.cnblogs.com/ityouknow/p/5614961.html" target="_blank" rel="noopener">JVM（3）：Java GC算法 垃圾收集器</a></li>
<li><a href="http://www.ityouknow.com/java/2017/03/01/jvm-overview.html" target="_blank" rel="noopener">JVM（3）：JVM知识点总览-高级Java工程师面试必备</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzAwNTQ4MTQ4NQ==&amp;mid=2453559994&amp;idx=1&amp;sn=4859ab4b755890515921e9d5bbeca597&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">JVM（10）：教你如何成为Java的OOM Killer</a></li>
<li><a href="https://blog.stormma.me/2017/04/21/java%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">Java 逃逸分析</a></li>
<li><a href="http://ginobefunny.com/post/jvm_interview_questions/" target="_blank" rel="noopener">面试小结之JVM篇</a></li>
</ol>
<h2 id="二、总结"><a href="#二、总结" class="headerlink" title="二、总结"></a>二、总结</h2>]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ClassLoader Blogs]]></title>
      <url>/2018/01/31/ClassLoader-Blogs/</url>
      <content type="html"><![CDATA[<h3 id="Java-类加载机制"><a href="#Java-类加载机制" class="headerlink" title="Java 类加载机制"></a>Java 类加载机制</h3><ol>
<li><a href="http://www.importnew.com/24381.html" target="_blank" rel="noopener">Java基础中一些值得聊的话题（加载篇）</a></li>
<li><a href="http://www.importnew.com/26269.html" target="_blank" rel="noopener">ClassLoader 揭秘</a></li>
<li><a href="http://www.cnblogs.com/ityouknow/p/5603287.html" target="_blank" rel="noopener">JVM（1）：Java 类的加载机制</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JVM </tag>
            
            <tag> ClassLoader </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Cllection Blogs]]></title>
      <url>/2018/01/30/collection-blogs/</url>
      <content type="html"><![CDATA[<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><ol>
<li><a href="http://www.importnew.com/26049.html" target="_blank" rel="noopener">深入并发包 ConcurrentHashMap</a></li>
</ol>
<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><ol>
<li><a href="https://www.jianshu.com/p/9e73b9216322" target="_blank" rel="noopener">并发队列–无界非阻塞队列 ConcurrentLinkedQueue 原理探究</a></li>
<li><a href="https://www.jianshu.com/p/05c6e392d378" target="_blank" rel="noopener">并发队列–无界阻塞队列 LinkedBlockingQueue 原理探究</a></li>
<li><a href="https://www.jianshu.com/p/ff116eaad0dd" target="_blank" rel="noopener">并发队列–有界阻塞队列 ArrayBlockingQueue 原理探究</a></li>
<li><a href="https://www.jianshu.com/p/fdf2163073d1" target="_blank" rel="noopener">并发队列-无界阻塞优先级队列 PriorityBlockingQueue 原理探究</a></li>
<li><a href="https://www.jianshu.com/p/2659eb72134b" target="_blank" rel="noopener">并发队列-无界阻塞延迟队列 DelayQueue 原理探究</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
            <category> 并发编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 集合 </tag>
            
            <tag> Map </tag>
            
            <tag> Queue </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
