<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java interview Summary]]></title>
    <url>%2F2018%2F03%2F08%2Fjava-interview-summary%2F</url>
    <content type="text"><![CDATA[一、基础篇1.1 Java基础 面向对象的特征：继承、封装和多态 final, finally, finalize 的区别 Exception、Error、运行时异常与一般异常有何异同 请写出5种常见到的runtime exception int 和 Integer 有什么区别，Integer的值缓存范围 包装类，装箱和拆箱 String、StringBuilder、StringBuffer 重载和重写的区别 抽象类和接口有什么区别 说说反射的用途及实现 说说自定义注解的场景及实现 HTTP请求的GET与POST方式的区别 Session与Cookie区别 列出自己常用的JDK包 MVC设计思想 equals与==的区别 hashCode和equals方法的区别与联系 什么是Java序列化和反序列化，如何实现Java序列化？或者请解释Serializable 接口的作用 Object类中常见的方法，为什么wait notify会放在Object里边？ Java的平台无关性如何体现出来的 JDK和JRE的区别 Java 8有哪些新特性 1.2 Java常见集合 List 和 Set 区别 Set和hashCode以及equals方法的联系 List 和 Map 区别 Arraylist 与 LinkedList 区别 ArrayList 与 Vector 区别 HashMap 和 Hashtable 的区别 HashSet 和 HashMap 区别 HashMap 和 ConcurrentHashMap 的区别 HashMap 的工作原理及代码实现，什么时候用到红黑树 多线程情况下HashMap死循环的问题 HashMap出现Hash DOS攻击的问题 ConcurrentHashMap 的工作原理及代码实现，如何统计所有的元素个数 手写简单的HashMap 看过那些Java集合类的源码 1.3、进程和线程 线程和进程的概念 进程：具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。 线程：它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源. 并行和并发的概念 并行是指两个或者多个事件在同一时刻发生 并发是指两个或多个事件在同一时间间隔发生 创建线程的方式及实现 进程间通信的方式？可參考《JAVA线程间通信的几种方式》 通过在线程之间共享对象就可以了，然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的 线程间通信的方式。可参考《线程间通信剖析》 为什么需要多线程(多线程的优势) 更多的计算核心（充分利用硬件资源） 更快的响应时间 更好的编程模型 什么是线程安全？ 如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。 线程安全也是有几个级别的 不可变String、Integer、Long 这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用 绝对线程安全不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet 相对线程安全相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个 Vector、有个线程同时在 add 这个 Vector，99% 的情况下都会出现 ConcurrentModificationException，也就是 fail-fast 机制。 线程非安全如：ArrayList、LinkedList、HashMap等都是线程非安全的类 如何保证线程安全？ 什么是线程安全？ 为什么会出现线程不安全？因为存在有限的共享资源（可变的共享变量），以及多线程的并发访问。 如何解决？ 尽量避免使用可变的共享变量 使用不可变的共享变量可以使用final修饰的对象保证线程安全，由于final修饰的引用型变量(除String外)不可变是指引用不可变，但其指向的对象是可变的，所以此类必须安全发布，也即不能对外提供可以修改final对象的接口。 线程同步 加锁 锁能使其保护的代码以串行的形式来访问，当给一个复合操作加锁后，能使其成为原子操作。一种错误的思想是只要对写数据的方法加锁，其实这是错的，对数据进行操作的所有方法都需加锁，不管是读还是写。 加锁时需要考虑性能问题，不能总是一味地给整个方法加锁synchronized就了事了，应该将方法中不影响共享状态且执行时间比较长的代码分离出去。 加锁的含义不仅仅局限于互斥，还包括可见性。为了确保所有线程都能看见最新值，读操作和写操作必须使用同样的锁对象。 CAS 算法 volatile 什么是 CAS？比较并交换(compare and swap, CAS)，是原子操作的一种，可用于在多线程编程中实现不被打断的数据交换操作，从而避免多线程同时改写某一数据时由于执行顺序不确定性以及中断的不可预知性产生的数据不一致问题。CAS操作基于CPU提供的原子操作指令实现，各个编译器根据这个特点实现了各自的原子操作函数。简单说：CAS需要检查操作值有没有发生改变，如果没有发生改变则更新。 优点： 缺点： 循环时间太长如果CAS一直不成功呢？这种情况绝对有可能发生，如果自旋CAS长时间地不成功，则会给CPU带来非常大的开销。在JUC中有些地方就限制了CAS自旋的次数，例如BlockingQueue的SynchronousQueue。 只能保证一个共享变量的原子操作（当然如果你有办法把多个变量整成一个变量，利用CAS也不错。例如读写锁中state的高地位） 存在 ABA问题 概念：如果一个值原来是A，变成了B，然后又变成了A，那么在CAS检查的时候会发现没有改变，但是实质上它已经发生了改变，这就是所谓的ABA问题。 解决：AtomicStampedReference 它可以通过控制变量值的版本来保证CAS的正确性，从而避免ABA问题。 引申：Java concurrent 并发包依赖于 CAS 算法，既然 CAS算法存在 ABA 问题，那是不是 AtomicInteger 等根本就不能用了呢？肯定是可以用的，AtomicInteger处理的一个数值，所有就算出现ABA问题问题，也不会有什么影响；但是如果这里是一个地址（地址被重用是很经常发生的，一个内存分配后释放了，再分配，很有可能还是原来的地址），比较地址发现没有问题，但其实这个对象早就变了，这时候就可以使用AtomicStampedReference来解决ABA问题。 说说 CountDownLatch, CyclicBarrier, Semaphore 原理和区别 概念 CountDownLatch：是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程的操作执行完后再执行。 CyclicBarrier： 它可以实现让一组线程等待至某个状态之后再全部同时执行。 Semaphore（默认非公平）：是一种基于计数的信号量。它可以设定一个阈值，基于此，多个线程竞争获取许可信号，做完自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。 原理 CountDownLatch 是通过一个计数器来实现的，计数器的初始值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就会减1。当计数器值到达0时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。 CyclicBarrier 内部定义了一个Lock对象，每当一个线程调用CyclicBarrier的await方法时，将剩余拦截的线程数减1，然后判断剩余拦截数是否为0，如果不是，进入Lock对象的条件队列等待。如果是，执行barrierAction对象的Runnable方法，然后将锁的条件队列中的所有线程放入锁等待队列中，这些线程会依次的获取锁、释放锁，接着先从await方法返回，再从CyclicBarrier的await方法中返回。 应用场景 CountDownLatch 实现最大的并行性有时我们想同时启动多个线程，实现最大程度的并行性。例如，我们想测试一个单例类。如果我们创建一个初始计数为1的CountDownLatch，并让所有线程都在这个锁上等待，那么我们可以很轻松地完成测试。我们只需调用 一次countDown()方法就可以让所有的等待线程同时恢复执行。 开始执行前等待n个线程完成各自任务：例如应用程序启动类要确保在处理用户请求前，所有N个外部系统已经启动和运行了。 CyclicBarrier可以用于多线程计算数据,最后合并计算结果的场景 Semaphore 可以用来构建一些对象池，资源池之类的，比如数据库连接池。 也可以创建计数为 1 的 Semaphore，将其作为一种类似互斥锁的机制 区别 CountDownLatch 一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行。 CyclicBarrier 一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行 Semaphore 其实和锁有点类似，它一般用于控制对某组资源的访问权限 实际上可以通过 CountDownLatch 的 countDown() 和 await() 来实现 CyclicBarrier 的功能。即 CountDownLatch 中的 countDown() + await() = CyclicBarrier 中的 await()。注意：在一个线程中先调用countDown()，然后调用await()。 说说 Exchanger 原理 Exchanger（交换者）是一个用于线程间协作的工具类。Exchanger 用于进行线程间的数据交换。它提供一个同步点，在这个同步点两个线程可以交换彼此的数据。这两个线程通过 exchange 方法交换数据， 如果第一个线程先执行 exchange 方法，它会一直等待第二个线程也执行 exchange，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。 使用场景：Exchanger 也可以用于校对工作 ThreadLocal 原理分析，ThreadLocal 为什么会出现 OOM，出现的深层次原理？ 原理：每个Thread 维护一个 ThreadLocalMap 映射表，这个映射表的 key 是 ThreadLocal实例本身，value 是真正需要存储的 Object。 ThreadLocal 本身并不存储值，它只是作为一个 key 来让线程从 ThreadLocalMap 获取 value。 ThreadLocalMap 是使用 ThreadLocal 的弱引用作为 Key 的，弱引用的对象在 GC 时会被回收。 作用：提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。 与普通变量的区别：每个使用该变量的线程都会初始化一个完全独立的实例副本。ThreadLocal 变量通常被 private static 修饰。当一个线程结束时，它所使用的所有 ThreadLocal 相对的实例副本都可被回收。 为什么会内存泄漏？ThreadLocalMap 使用 ThreadLocal 的弱引用作为 key，如果一个 ThreadLocal 没有外部强引用来引用它，那么系统 GC 时，这个 ThreadLocal 会被回收，ThreadLocalMap 中就会出现 key 为 null 的 Entry，就没有办法访问这些 key 为 null 的 Entry 的 value，如果当前线程再迟迟不结束的话，这些 key 为 null 的 Entry 的 value 就会一直存在一条强引用链：Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value 永远无法回收，造成内存泄漏。 适用场景： ThreadLocal 适用于变量在线程间隔离且在方法间共享的场景 可参考： 正确理解 ThreadLocal 的原理与适用场景 深入分析 ThreadLocal 内存泄漏问题 讲讲线程池的实现原理 线程池的几种实现方式 线程的生命周期，状态是如何转移的 如何理解并发的三个特性：原子性、可见性、顺序性？ 原子性：原子性是指不可再分的最小操作指令，即单条机器指令，原子性操作任意时刻只能有一个线程，因此是线程安全的。 可见性：指当多个线程并发访问共享变量时，一个线程对共享变量的修改，其它线程能够立即看到。 顺序性： 可参考：《Java多线程编程核心技术》 可参考：《40个Java多线程问题总结》 1.4 锁机制 什么是锁？锁是保证并发共享数据一致性的工具 Java 中常见的锁有哪些？ 阻塞锁 概念：可以说是让线程进入阻塞状态进行等待，当获得相应的信号（唤醒，时间）时，才可以进入线程的准备就绪状态，准备就绪状态的所有线程，通过竞争，进入运行状态。 按照锁性质分类： 公平锁/非公平锁 互斥锁/读写锁 悲观锁/乐观锁 独享锁/共享锁 可重入锁 按照设计方案分类： 自旋锁 概念：自旋锁是采用让当前线程不停地的在循环体内执行实现的，当循环的条件被其他线程改变时 才能进入临界区。 适用场景：适合于线程竞争不激烈，且锁保持时间短。因为自旋锁只是将当前线程不停地执行循环体，不进行线程状态的改变，所以响应速度更快。但当线程数不停增加时，性能下降明显，因为每个线程都需要执行，占用CPU时间。 锁膨胀/锁消除 偏向锁/轻量级锁/重量级锁 分段锁 对象锁 线程锁 信号量可参考：JAVA锁有哪些种类 Condition 重入锁的概念，重入锁为什么可以防止死锁 产生死锁的四个条件（互斥、请求与保持、不剥夺、循环等待） 如何检查死锁（通过jConsole检查死锁） volatile 实现原理（禁止指令重排、刷新内存） synchronized 实现原理（对象监视器） synchronized 与 lock 的区别 AQS同步队列 CAS无锁的概念、乐观锁和悲观锁 常见的原子操作类 乐观锁的业务场景及实现方式 Java 8并法包下常见的并发类 偏向锁、轻量级锁、重量级锁、自旋锁的概念 可参考：《Java多线程编程核心技术》 1.5、JVM JVM 运行时内存区域划分 JVM 如何加载字节码文件 什么情况会出现Full GC，什么情况会出现yong GC。 内存溢出 OOM 和堆栈溢出SOE的示例及原因、如何排查与解决 如何判断对象是否可以回收或存活 常见的GC回收算法及其含义 常见的JVM性能监控和故障处理工具类：jps、jstat、jmap、jinfo、jconsole等 JVM如何设置参数 JVM性能调优 类加载器、双亲委派模型、一个类的生命周期、类是如何加载到JVM中的 类加载的过程：加载、验证、准备、解析、初始化 强引用、软引用、弱引用、虚引用 Java内存模型JMM 可参考《《深入理解 Java 内存模型》读书笔记》 1.6、设计模式 常见的设计模式 设计模式的的六大原则及其含义 常见的单例模式以及各种实现方式的优缺点，哪一种最好，手写常见的单利模式 设计模式在实际场景中的应用 Spring中用到了哪些设计模式 MyBatis中用到了哪些设计模式 你项目中有使用哪些设计模式 说说常用开源框架中设计模式使用分析 动态代理很重要！！！ 1.7、数据结构 树（二叉查找树、平衡二叉树、红黑树、B树、B+树） 深度有限算法、广度优先算法 克鲁斯卡尔算法、普林母算法、迪克拉斯算法 什么是一致性Hash及其原理、Hash环问题 常见的排序算法和查找算法：快排、折半查找、堆排序等 1.8、网络/IO基础 BIO、NIO、AIO的概念 什么是长连接和短连接 Http1.0和2.0相比有什么区别，可参考《Http 2.0》 Https的基本概念 三次握手和四次挥手、为什么挥手需要四次 从游览器中输入URL到页面加载的发生了什么？可参考《从输入URL到页面加载发生了什么》 二、数据存储和消息队列2.1、数据库 MySQL 索引使用的注意事项 DDL、DML、DCL分别指什么 explain命令 left join，right join，inner join 数据库事物ACID（原子性、一致性、隔离性、持久性） 事物的隔离级别（读未提交、读以提交、可重复读、可序列化读） 脏读、幻读、不可重复读 数据库的几大范式 数据库常见的命令 说说分库与分表设计 分库与分表带来的分布式困境与应对之策（如何解决分布式下的分库分表，全局表？） 说说 SQL 优化之道。可参考《19个MySQL性能优化要点解析》 MySQL遇到的死锁问题、如何排查与解决 存储引擎的 InnoDB与MyISAM区别，优缺点，使用场景 索引类别（B+树索引、全文索引、哈希索引）、索引的原理 什么是自适应哈希索引（AHI） 为什么要用 B+tree作为MySQL索引的数据结构 聚集索引与非聚集索引的区别 遇到过索引失效的情况没，什么时候可能会出现，如何解决 limit 20000 加载很慢怎么解决 如何选择合适的分布式主键方案 选择合适的数据存储方案 常见的几种分布式ID的设计方案 常见的数据库优化方案，在你的项目中数据库如何进行优化的 2.2、Redis Redis 有哪些数据类型，可参考《Redis常见的5种不同的数据类型详解》 Redis 内部结构 Redis 使用场景 Redis 持久化机制，可参考《使用快照和AOF将Redis数据持久化到硬盘中》 Redis 集群方案与实现 Redis 为什么是单线程的？ 缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级 使用缓存的合理性问题 Redis常见的回收策略 2.3、消息队列 消息队列的使用场景 消息的重发补偿解决思路 消息的幂等性解决思路 消息的堆积解决思路 自己如何实现消息队列 如何保证消息的有序性 三、开源框架和容器3.1 Servlet Servlet的生命周期 转发与重定向的区别 3.2 Spring 什么是 Spring，你对 Spring 的理解？ Spring是一个轻型容器(light-weight container)，其核心是Bean工厂(Bean Factory)，用以构造我们所需要的M(Model)。 在此基础之上，Spring 提供了AOP（Aspect-Oriented Programming, 面向层面的编程）的实现，用它来提供声明式事务、安全等服务； 对 Bean 工厂的扩展ApplicationContext更加方便我们实现J2EE的应用； DAO/ORM 的实现方便我们进行数据库的开发； Web MVC 和 Spring Web 提供了 Java Web 应用的框架或与其他流行的 Web 框架进行集成。 BeanFactory 和 ApplicationContext 有什么区别 Spring Bean 的生命周期 Spring 容器 从XML 文件中读取 Bean 的定义，并实例化bean。 Spring 根据 Bean 的定义填充所有的属性。 如果 Bean 实现了BeanNameAware 接口，Spring 传递 Bean 的ID 到 setBeanName方法。 如果 Bean 实现了 BeanFactoryAware 接口， Spring 传递 Beanfactory 给 setBeanFactory 方法。 如果有任何与 Bean 相关联的 BeanPostProcessors，Spring 会在 postProcesserBeforeInitialization()方法内调用它们。 如果 Bean 实现 IntializingBean 了，调用它的 afterPropertySet 方法，如果 Bean 声明了初始化方法，调用此初始化方法。 如果有 BeanPostProcessors 和 Bean 关联，这些 Bean 的 postProcessAfterInitialization() 方法将被调用。 如果 Bean 实现了 DisposableBean，它将调用 destroy()方法。 Spring IOC 如何实现。可参考《三条路线告诉你如何掌握Spring IoC容器的核心原理》 Spring中Bean的作用域，默认的是哪一个？ Singleton Spring IoC 是什么？IOC:控制反转也叫依赖注入，IOC利用java反射机制，AOP利用代理模式。所谓控制反转是指，本来被调用者的实例是有调用者来创建的，这样的缺点是耦合性太强，IOC则是统一交给spring来管理创建，将对象交给容器管理，你只需要在spring配置文件总配置相应的bean，以及设置相关的属性，让spring容器来生成类的实例对象以及管理对象。在spring容器启动的时候，spring会把你在配置文件中配置的bean都初始化好，然后在你需要调用的时候，就把它已经初始化好的那些bean分配给你需要调用这些bean的类。 说说 Spring AOP面向切面编程（AOP）完善spring的依赖注入（DI），面向切面编程在spring中主要表现为两个方面1.面向切面编程提供声明式事务管理2.spring支持用户自定义的切面 Spring AOP 实现原理实现 AOP 的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行； jdk 动态代理 Cglib二是采用静态织入的方式。 针对每个具体类分别编写代理类；针对一个接口编写一个代理类； Spring 切面可以应用的通知类型有哪些？ before：前置通知，在一个方法执行前被调用。 after: 在方法执行之后调用的通知，无论方法执行是否成功。 after-returning: 仅当方法成功完成后执行的通知。 after-throwing: 在方法抛出异常退出时执行的通知。 around: 在方法执行之前和之后调用的通知。 动态代理（CGLib 与 JDK）、优缺点、性能对比、如何选择？ Spring 事务实现方式、事务的传播机制、默认的事务类别 Spring 事务底层原理 Spring事务失效（事务嵌套），JDK动态代理给Spring事务埋下的坑，可参考《JDK动态代理给Spring事务埋下的坑！》 如何自定义注解实现功能 Spring MVC 工作原理 &amp; 执行流程？ 工作原理 SpringMvc 把请求交给 DispactherServlet DispactherServlet 查询一个或者多个 HanderMapping DispactherServlet 请求 Controller Controller 进行业务逻辑处理 找到制定的视图对象 视图负责渲染返回给客户端 执行流程 根据配置文件创建 Spring 的容器 发送 http 请求到核心控制器 容器通过映射去寻找业务控制器 使用适配器找到相应的业务类，在业务类进行封装 数据放到 Model中 用 Map 传递数据进行页面展示 Spring MVC 启动流程 Spring 的单例实现原理 Spring 框架中用到了哪些设计模式 Spring 其他产品（Srping Boot、Spring Cloud、Spring Secuirity、Spring Data、Spring AMQP 等） 有没有用到 Spring Boot，Spring Boot的认识、原理 MyBatis的原理 可参考《为什么会有Spring》 可参考《为什么会有Spring AOP》 可参考《Spring历史版本变迁和如今的生态帝国》3.2、Netty 为什么选择 Netty 说说业务中，Netty 的使用场景 原生的 NIO 在 JDK 1.7 版本存在 epoll bug 什么是TCP 粘包/拆包 TCP粘包/拆包的解决办法 Netty 线程模型 说说 Netty 的零拷贝 Netty 内部执行流程 Netty 重连实现 3.3、Tomcat Tomcat的基础架构（Server、Service、Connector、Container） Tomcat如何加载Servlet的 Pipeline-Valve机制 可参考：《四张图带你了解Tomcat系统架构！》 四、分布式4.1、Nginx 请解释什么是C10K问题或者知道什么是C10K问题吗？ Nginx简介，可参考《Nginx简介》 正向代理和反向代理. Nginx几种常见的负载均衡策略 Nginx服务器上的Master和Worker进程分别是什么 使用“反向代理服务器”的优点是什么? 4.2、分布式其他 谈谈业务中使用分布式的场景 Session 分布式方案 Session 分布式处理 分布式锁的应用场景、分布式锁的产生原因、基本概念 分布是锁的常见解决方案 分布式事务的常见解决方案 集群与负载均衡的算法与实现 怎么提升系统的QPS和吞吐量 如何保证消息的一致性 CDN 实现原理 说说分库与分表设计，可参考《数据库分库分表策略的具体实现方案》 分库与分表带来的分布式困境与应对之策 4.3、Dubbo 什么是Dubbo，可参考《Dubbo入门》 什么是RPC、如何实现RPC、RPC 的实现原理，可参考《基于HTTP的RPC实现》 Dubbo中的SPI是什么概念 Dubbo的基本原理、执行流程 五、微服务5.1、微服务 前后端分离是如何做的？ 微服务哪些框架 Spring Could的常见组件有哪些？可参考《Spring Cloud概述》 领域驱动有了解吗？什么是领域驱动模型？充血模型、贫血模型 JWT有了解吗，什么是JWT，可参考《前后端分离利器之JWT》 你怎么理解 RESTful 说说如何设计一个良好的 API 如何理解 RESTful API 的幂等性 如何保证接口的幂等性 说说 CAP 定理、BASE 理论 怎么考虑数据一致性问题 说说最终一致性的实现方案 微服务的优缺点，可参考《微服务批判》 微服务与 SOA 的区别 如何拆分服务、水平分割、垂直分割 如何应对微服务的链式调用异常 如何快速追踪与定位问题 如何保证微服务的安全、认证 5.2、安全问题 如何防范常见的Web攻击、如何方式SQL注入 服务端通信安全攻防 HTTPS原理剖析、降级攻击、HTTP与HTTPS的对比 5.3、性能优化 性能指标有哪些 如何发现性能瓶颈 性能调优的常见手段 说说你在项目中如何进行性能调优 六、其他6.1、设计能力 说说你在项目中使用过的 UML 图 你如何考虑组件化、服务化、系统拆分 秒杀场景如何设计 有没有处理过线上问题？出现内存泄露，CPU 利用率标高，应用无响应时如何处理的。 开发中有没有遇到什么技术问题？如何解决的 如果有几十亿的白名单，每天白天需要高并发查询，晚上需要更新一次，如何设计这个功能。 新浪微博是如何实现把微博推给订阅者 Google 是如何在一秒内把搜索结果返回给用户的。 12306 网站的订票系统如何实现，如何保证不会票不被超卖。 如何实现一个秒杀系统，保证只有几位用户能买到某件商品。 可参考：《秒杀系统的技术挑战、应对策略以及架构设计总结一二！》 可参考：《大型网站应用之海量数据和高并发解决方案总结一二》 6.2、业务工程 说说你的开发流程、如何进行自动化部署的 你和团队是如何沟通的 你如何进行代码评审 说说你对技术与业务的理解 说说你在项目中遇到感觉最难Bug，是如何解决的 介绍一下工作中的一个你认为最有价值的项目，以及在这个过程中的角色、解决的问题、你觉得你们项目还有哪些不足的地方 6.3、软实力 说说你的优缺点、亮点 说说你最近在看什么书、什么博客、在研究什么新技术、再看那些开源项目的源代码 说说你觉得最有意义的技术书籍 工作之余做什么事情、平时是如何学习的，怎样提升自己的能力 说说个人发展方向方面的思考 说说你认为的服务端开发工程师应该具备哪些能力 说说你认为的架构师是什么样的，架构师主要做什么 如何看待加班的问题]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring]]></title>
    <url>%2F2018%2F03%2F07%2Fspring%2F</url>
    <content type="text"><![CDATA[Spring AOP 设计原理]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8 Blogs]]></title>
    <url>%2F2018%2F03%2F07%2Fjava-io%2F</url>
    <content type="text"><![CDATA[一、相关帖子整理 面试小结之IO篇]]></content>
      <categories>
        <category>IO</category>
      </categories>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis]]></title>
    <url>%2F2018%2F03%2F07%2Fredis%2F</url>
    <content type="text"><![CDATA[1. Redis 有哪些数据结构？ String(字符串) append set get / mget incr Hash(字典) hset hget hdel hexist hincrby List(列表) lpush / rpush lpop / rpop blpop / brpop- Set(集合) sadd smove ：将 member 元素从 source 集合移动到 destination 集合。[SMOVE source destination member] spop ：移除并返回集合中的一个随机元素。 srem ：移除集合 key 中的一个或多个 member 元素，不存在的 member 元素会被忽略。[SREM key member [member …]] smembers：返回集合 key 中的所有成员。[SMEMBERS key] SortedSet(有序集合) zadd zincrby zrem / zremrangebyrank zrange / zrangebyscore HyperLogLog 用于基数统计 HyperLogLog 键内存占用仅需 12K，可计算近 2^64 个不同元素的基数。 算法给出的基数并不是精确的，是估算值。 Geo Pub/Sub(发布订阅) publish subscribe unsubscribe 2. 如何使用 Redis 实现分布式锁？ 先用 setnx 来争抢锁，抢到之后，再用 expire 给锁加一个过期时间防止锁忘记了释放。或者直接使用：1SET key-with-expire-and-NX &quot;lock&quot; EX 10086 NX 3. 假如 Redis 里面有1亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？ 使用 keys 指令可以扫出指定模式的 key 列表。 如果这个 redis 正在给线上的业务提供服务，那使用 keys 指令会有什么问题？redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。 4. 如何使用 Redis 实现异步队列？ 一般使用 list 结构作为队列，rpush 生产消息，lpop 消费消息。当 lpop 没有消息的时候，要适当 sleep 一会再重试。 可不可以不用 sleep？list 还有个指令叫 blpop，在没有消息的时候，它会阻塞住直到消息到来。 能不能生产一次消费多次呢？使用pub/sub主题订阅者模式，可以实现1:N的消息队列。 Redis 如何实现延时队列？ 使用 sortedset，拿时间戳作为 score，调用 zadd 来生产消息，消费者用 zrangebyscore 指令获取 N 秒之前的数据轮询进行处理。 5. 如果有大量的 key 需要设置同一时间过期，一般需要注意什么？ 如果大量的 key 过期时间设置的过于集中，到过期的那个时间点，redis 可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一些。 6. Redis 如何做持久化？ 使用 BGSAVE 命令做镜像全量持久化。 bgsave 的原理是什么？命令执行之后立即返回 OK ，然后 Redis fork 出一个新子进程，原来的 Redis 进程(父进程)继续处理客户端请求，而子进程则负责将数据保存到磁盘，然后退出。 RDB 持久化可以在指定的时间间隔内生成数据集的时间点快照 AOF 持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。 Redis 还可以同时使用 AOF 持久化和 RDB 持久化。 在这种情况下， 当 Redis 重启时， 它会优先使用 AOF 文件来还原数据集， 因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。 7. Pipeline有什么好处，为什么要用pipeline？ 可以将多次 IO 往返的时间缩减为一次，前提是 pipeline 执行的指令之间没有因果相关性。 8. Redis的同步机制了解么？ Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。 9. Redis 集群原理？ Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。 Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。 10. Redis 常见应用场景 全页面缓存 排行榜 Session 存储 队列 发布/订阅 分布式锁 案例 Redis在京东到家的订单中的使用 引用： 天下无难试之Redis面试刁难大全]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Skills]]></title>
    <url>%2F2018%2F02%2F02%2Fjava-skills%2F</url>
    <content type="text"><![CDATA[专业技能 Java 面试题整理(没有答案) Java面试题全集（上） Java面试题全集（中） Java面试题全集（下） 关于Java面试，你应该准备这些知识点 基本语法 static, final, transient 等关键字作用 volatile 抽象类与接口的区别 集合 Java - 集合框架完全解析 40个Java集合面试问题和答案 ListMapHashMapConcurrentHashMap 锁分段技术（Java8 之前版本） 读操作是否要加锁，为什么。 其迭代器是强一致性的还是弱一致性的。 SetQueueIOFile IOSocket IO 概念 搞懂阻塞/非阻塞的区别、同步/异步的区别 理解阻塞IO、非阻塞IO、多路复用IO、异步IO这四种IO模型 Socket IO 如何和这四种模型相关联 NIO的原理 NIO属于哪种IO模型 NIO的三大组成 Netty 泛型反射多线程JVM Java 虚拟机的内存布局 GC 算法及几种垃圾收集器 类加载机制，也就是双亲委派模型 Java 内存模型 happens-before 规则 volatile 关键字使用规则 JSR-133 volatile final 语义增强 数据库 《高性能Mysql》读书笔记 复杂SQL与优化 事务机制 Spring事务应用 索引原理 开源框架Spring Spring 知识点 69道Spring面试题和答案 Spring BootSpring MVCHibernateMybatisRedisDubboZookeeperKafka http://www.jasongj.com/tags/Kafka/ 数据结构 很全面的算法和数据结构知识 常见数据结构与算法整理总结（上） 常见数据结构与算法整理总结（下） 数组链表栈队列树 二叉查找树 平衡二叉查找树（AVL树） 红黑树 算法 常见排序算法2.3. 设计模式Java Web Servlet 原理 生命周期 Tomcat 架构能力用过哪些中间件：Zookeeper, KafkaZookeeper 作用分布式事务解决缓存对 CAP, BASE, ACID 的理解面试 程序员如何写出杀手级的简历 十大面试问题解惑 项目经验提问方式 连环提问 多线程模型 - &gt; 各种状态之间转换 -&gt; jdk常见的并发类 -&gt; 如何保证线程安全 -&gt; volatile 实现原理 -&gt; 线程池与队列 -&gt; 调优 spring 特点 -&gt; AOP 原理 -&gt; 代理种类 -&gt; 实现细节 -&gt; CGLib 局限 -&gt; 性能如何 JVM 组成 -&gt; 内存模型 -&gt; 垃圾收集算法 -&gt; 类加载 -&gt; 收集器类型 -&gt; 如何调优 spring MVC 组成 - &gt; 怎么映射控制器 -&gt; 控制器单例否 -&gt; 拦截器应用 使用过 MySQL -&gt; 数据库引擎区别 -&gt; 事务控制 - &gt; 隔离级别 -&gt; 加锁种类区别 -&gt; spring事务传播 -&gt; 区别 分布式和集群区别 -&gt; 服务发现和负载均衡 -&gt; 中间件 -&gt; 分布式事务处理 -&gt; 缓存设计 引用 http://www.cnblogs.com/xrq730/p/5260294.htmlhttps://segmentfault.com/a/1190000004716061http://blog.csdn.net/micro_hz/article/details/77992185]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Microservice Blogs]]></title>
    <url>%2F2018%2F02%2F01%2Fmicroservice%2F</url>
    <content type="text"><![CDATA[多研究些架构，少谈些框架 论微服务架构的核心概念 微服务和充血模型 微服务和事件驱动 架构师是技术的使用者而不是信徒]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式 Blogs]]></title>
    <url>%2F2018%2F02%2F01%2Fdesign-patterns%2F</url>
    <content type="text"><![CDATA[常用开源框架中设计模式使用分析 单例设计模式 jdk中的23种设计模式体现]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库 Blogs]]></title>
    <url>%2F2018%2F02%2F01%2Fdatabase%2F</url>
    <content type="text"></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Computer Network Blogs]]></title>
    <url>%2F2018%2F02%2F01%2Fcomputer-network%2F</url>
    <content type="text"><![CDATA[就是要你懂TCP – 握手和挥手]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 并发编程 Blogs]]></title>
    <url>%2F2018%2F02%2F01%2Fconcurrency-programming%2F</url>
    <content type="text"><![CDATA[高并发编程必备基础(上) 高并发编程必备基础(下)]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8 Blogs]]></title>
    <url>%2F2018%2F01%2F31%2Fjava8%2F</url>
    <content type="text"><![CDATA[Java 8的新特性—终极版]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM Blogs]]></title>
    <url>%2F2018%2F01%2F31%2Fjvm-blogs%2F</url>
    <content type="text"><![CDATA[一、相关帖子整理 JAVA的内存模型及结构 JVM（2）：JVM内存结构 JVM（3）：Java GC算法 垃圾收集器 JVM（3）：JVM知识点总览-高级Java工程师面试必备 JVM（10）：教你如何成为Java的OOM Killer Java 逃逸分析 面试小结之JVM篇 二、总结]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ClassLoader Blogs]]></title>
    <url>%2F2018%2F01%2F31%2FClassLoader-Blogs%2F</url>
    <content type="text"><![CDATA[Java 类加载机制 Java基础中一些值得聊的话题（加载篇） ClassLoader 揭秘 JVM（1）：Java 类的加载机制]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>ClassLoader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cllection Blogs]]></title>
    <url>%2F2018%2F01%2F30%2Fcollection-blogs%2F</url>
    <content type="text"><![CDATA[Map 深入并发包 ConcurrentHashMap Queue 并发队列–无界非阻塞队列 ConcurrentLinkedQueue 原理探究 并发队列–无界阻塞队列 LinkedBlockingQueue 原理探究 并发队列–有界阻塞队列 ArrayBlockingQueue 原理探究 并发队列-无界阻塞优先级队列 PriorityBlockingQueue 原理探究 并发队列-无界阻塞延迟队列 DelayQueue 原理探究]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>集合</tag>
        <tag>Map</tag>
        <tag>Queue</tag>
      </tags>
  </entry>
</search>
